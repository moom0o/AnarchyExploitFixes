package me.xginko.aef.commands.aef;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import me.xginko.aef.commands.AEFCommand;
import me.xginko.aef.commands.SubCommand;
import me.xginko.aef.commands.aef.subcommands.DisableSubCmd;
import me.xginko.aef.commands.aef.subcommands.ElytraSubCmd;
import me.xginko.aef.commands.aef.subcommands.GearedSubCmd;
import me.xginko.aef.commands.aef.subcommands.LagSubCmd;
import me.xginko.aef.commands.aef.subcommands.ReloadSubCmd;
import me.xginko.aef.commands.aef.subcommands.VersionSubCmd;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import org.bukkit.command.CommandException;
import org.bukkit.command.CommandSender;
import org.jetbrains.annotations.NotNull;

import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AEFCmd extends AEFCommand {

    private final @NotNull Set<SubCommand> subCommands;
    private final @NotNull List<String> tabCompletes;
    private final @NotNull List<Component> overview;

    public AEFCmd() {
        super(
                "aef",
                "AnarchyExploitFixes admin commands",
                "/aef <reload, version, bytesize, disable, elytra, geared, lag>",
                Collections.emptyList()
        );
        this.overview = Stream.of(
                "",
                "                 <#00edff><bold>AnarchyExploitFixes Commands",
                "",
                "  <#00edff>/aef version <#869699>- <#e2fdff>Show the plugin version.",
                "  <#00edff>/aef reload <#869699>- <#e2fdff>Reload the plugin.",
                "  <#00edff>/aef disable <#869699>- <#e2fdff>Disable the plugin.",
                "  <#00edff>/aef lag <millis> <#869699>- <#e2fdff>Lag the server for testing.",
                "  <#00edff>/aef geared <#869699>- <#e2fdff>Count how many players are wearing gear.",
                "  <#00edff>/aef elytra <#869699>- <#e2fdff>Count how many players are flying elytra.",
                "  <#00edff>/aef bytesize <mainhand/inventory> (player) (utf8/utf16)",
                "                      <#869699>- <#e2fdff>Get the byte size of an item or inventory.",
                ""
        ).map(MiniMessage.miniMessage()::deserialize)
                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf));
        this.subCommands = ImmutableSet.of(
                new ReloadSubCmd(),
                new VersionSubCmd(),
                new DisableSubCmd(),
                new LagSubCmd(),
                new ElytraSubCmd(),
                new GearedSubCmd());
        this.tabCompletes = subCommands.stream().map(SubCommand::label).sorted()
                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf));
    }

    @Override
    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args)
            throws CommandException, IllegalArgumentException
    {
        if (args.length == 1) {
            return tabCompletes.stream()
                    .filter(cmd -> cmd.toLowerCase(Locale.ROOT).startsWith(args[0].toLowerCase(Locale.ROOT)))
                    .collect(Collectors.toList());
        }

        if (args.length > 1) {
            for (SubCommand subCommand : subCommands) {
                if (args[0].equalsIgnoreCase(subCommand.label())) {
                    return subCommand.tabComplete(sender, alias, args);
                }
            }
        }

        return Collections.emptyList();
    }

    @Override
    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
        if (args.length > 0) {
            for (SubCommand subCommand : subCommands) {
                if (args[0].equalsIgnoreCase(subCommand.label())) {
                    return subCommand.execute(sender, commandLabel, args);
                }
            }
        }

        overview.forEach(sender::sendMessage);
        return true;
    }
}
