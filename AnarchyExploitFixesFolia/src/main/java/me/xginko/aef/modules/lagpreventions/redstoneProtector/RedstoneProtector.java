package me.xginko.aef.modules.lagpreventions.redstoneProtector;

import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import org.bukkit.event.EventHandler;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockRedstoneEvent;

import java.util.HashMap;
import java.util.Map;

public class RedstoneProtector extends AEFModule implements Listener {
    private final int regionSize, redstoneLimit, redstoneLimitResetTime, slimeLimit, slimeLimitResetTime, LimitBanTime;
    private final boolean logIsEnabled;
    private final Map<Integer, RegionData> regionMap;

    public RedstoneProtector() {
        super("lag-preventions.redstone-protector");
        this.regionMap = new HashMap<>();
        config.addComment(configPath + ".enable", """
                A modern defense against lag machines that are made as mechanisms.\s
                The configuration has basic settings, but you can do better.\s
                The defense has been used on the 6g6s.org project for several years and has performed well.\s
                Slime limiter is used to fix EMP lag of the machine: https://www.youtube.com/watch?v=R_S8o4hngNI\s
                Demonstration of how this module works: https://www.youtube.com/watch?v=Rmlm-OVuBss
                """);
        this.regionSize = config.getInt(configPath + ".region-size", 1500, "Radius of the region in blocks. Redstone is limited by region. It is recommended to be at least 1000.");
        this.LimitBanTime = config.getInt(configPath + ".limit-ban-time", 180, "The time for which all redstone will be disabled if the limit is exceeded. (in seconds)");
        this.redstoneLimit = config.getInt(configPath + ".redstone-limit.count", 5000, "Maximum number of redstone bursts in x milliseconds.");
        this.redstoneLimitResetTime = config.getInt(configPath + ".redstone-limit.reset-time", 5000, "The time after which the redstone burst counter will reset. (in milliseconds)");
        this.slimeLimit = config.getInt(configPath + ".slime-limit.count", 500, "Maximum number of movements for slime blocks in x milliseconds.");
        this.slimeLimitResetTime = config.getInt(configPath + ".slime-limit.reset-time", 5000, "The time after which the slime burst counter will reset. (in milliseconds)");
        this.logIsEnabled = config.getBoolean(configPath + ".log", true);
        plugin.getServer().getGlobalRegionScheduler().runAtFixedRate(plugin, task -> redstoneCounterReset(), 10 * 20, 20 * (redstoneLimitResetTime/1000));
        plugin.getServer().getGlobalRegionScheduler().runAtFixedRate(plugin, task -> slimeCounterReset(), 10 * 20, 20 * (slimeLimitResetTime/1000));
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @EventHandler
    private void redstoneFlashEvent(BlockRedstoneEvent event) {
        int regionNumber = RegionData.getRegion(event.getBlock().getX(), event.getBlock().getZ(), this.regionSize);

        if (!regionMap.containsKey(regionNumber)) {
            RegionData regionData = new RegionData(0, 0, false);
            regionMap.put(regionNumber, regionData);
        }

        RegionData region = regionMap.get(regionNumber);
        region.setCurrentRedstoneLimit(region.getCurrentRedstoneLimit() + 1);

        if (region.getCurrentRedstoneLimit() > redstoneLimit) {
            if (!region.isBlocked()) {
                blockRegion(regionNumber, LimitBanTime);
                if (logIsEnabled) warn("Blocked redstone in the region " + regionNumber + " at " +
                        LocationUtil.toString(event.getBlock().getLocation()) +
                        " because the limit has been exceeded. Limit: " + region.getCurrentRedstoneLimit() + " / " + redstoneLimit);
            }
        }

        if (region.isBlocked()) {
            event.setNewCurrent(0);
        }
    }

    @EventHandler
    private void SlimePatch(BlockPistonExtendEvent event) {
        int regionNumber = RegionData.getRegion(event.getBlock().getX(), event.getBlock().getZ(), this.regionSize);

        if (!regionMap.containsKey(regionNumber)) {
            RegionData regionData = new RegionData(0, 0, false);
            regionMap.put(regionNumber, regionData);
        }

        RegionData region = regionMap.get(regionNumber);
        region.setCurrentSlimeLimit(region.getCurrentSlimeLimit() + 1);

        if (region.getCurrentSlimeLimit() > slimeLimit) {
            if (!region.isBlocked()) {
                blockRegion(regionNumber, LimitBanTime);
                if (logIsEnabled) warn("Blocked redstone in the region " + regionNumber + " at " +
                        LocationUtil.toString(event.getBlock().getLocation()) +
                        " because the slime limit has been exceeded. Limit: " + region.getCurrentSlimeLimit() + " / " + slimeLimit);
            }
        }

        if (region.isBlocked()) {
            event.setCancelled(true);
        }
    }

    private void redstoneCounterReset() {
        for (RegionData regionData : regionMap.values()) {
            regionData.setCurrentRedstoneLimit(0);
        }
    }

    private void slimeCounterReset() {
        for (RegionData regionData : regionMap.values()) {
            regionData.setCurrentSlimeLimit(0);
        }
    }

    public void blockRegion(int regionNumber, long durationInSeconds) {
        if (regionMap.containsKey(regionNumber)) {
            RegionData regionData = regionMap.get(regionNumber);
            long currentTime = System.currentTimeMillis() / 1000;
            regionData.setBlocked(true, currentTime, durationInSeconds);
        }
    }
}
