package me.xginko.aef.modules.combat;

import me.xginko.aef.modules.AEFModule;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPistonExtendEvent;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class PistonPush extends AEFModule implements Listener {

    private final Set<EntityType> pushDisabledTypes;

    public PistonPush() {
        super("combat.piston-push", false,"""
                Disables pistons from extending if it would push certain configured entities.
                This can be used to prevent players from pushing other players out of burrows, by
                configuring PLAYER, or to disable piston-crystal by adding ENDER_CRYSTAL to the list.""");
        this.pushDisabledTypes = config.getList(configPath+".piston-push-blocked-entities", Collections.singletonList("PLAYER"))
                .stream()
                .map(configuredType -> {
                    try {
                        return EntityType.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(EntityType.class)));
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPistonExtend(BlockPistonExtendEvent event) {
        for (Entity entity : event.getBlock().getRelative(event.getDirection()).getLocation().getNearbyEntities(1,1,1)) {
            if (pushDisabledTypes.contains(entity.getType())) {
                event.setCancelled(true);
                return;
            }
        }
    }
}
