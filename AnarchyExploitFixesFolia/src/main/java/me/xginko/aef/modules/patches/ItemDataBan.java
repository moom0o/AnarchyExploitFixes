package me.xginko.aef.modules.patches;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.ItemUtil;
import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.ItemSpawnEvent;
import org.bukkit.event.player.PlayerAttemptPickupItemEvent;
import org.bukkit.event.player.PlayerEditBookEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerKickEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BookMeta;

import java.time.Duration;
import java.util.UUID;

public class ItemDataBan extends AEFModule implements Listener {

    private final long itemSizeCacheMillis, inventorySizeCacheMillis;
    private final int maxBookSize, maxItemSize, maxInventorySize, maxAuthorChars, maxTitleChars, maxPages;
    private final boolean useUTF16, kickOnBigBook;

    private Cache<UUID, Integer> cachedItemSizes, cachedInventorySizes;

    public ItemDataBan() {
        super("patches.anti-item-ban", false, """
                More commonly known as book-ban:\s
                Prevents player's getting banned from items with big nbt/compound data.\s
                This check applies to all item data, not just books.""");
        this.useUTF16 = config.getBoolean(configPath + ".use-UTF-16", false, """
                If set to false, will use UTF-8.\s
                Charset to use to encode the result of NBTCompound#toString into\s
                a sequence of bytes. The length of that sequence is then used to\s
                get the approximate Byte-size of an ItemStack.\s
                Use the /aef bytesize command to get a better understanding.""");
        this.maxBookSize = config.getInt(configPath + ".max-book-size", 56000);
        this.kickOnBigBook = config.getBoolean(configPath + ".kick-on-too-large-book-edit", true,
                "Kicks players when they try to create a book bigger than the limit.");
        this.maxAuthorChars = config.getInt(configPath + ".max-author-chars", 30);
        this.maxTitleChars = config.getInt(configPath + ".max-title-chars", 30);
        this.maxPages = config.getInt(configPath + ".max-pages", 100);
        this.maxItemSize = config.getInt(configPath + ".max-item-size", 56000);
        this.maxInventorySize = config.getInt(configPath + ".max-inventory-size", 2050000);
        this.itemSizeCacheMillis = Math.max(1,config.getInt(configPath + ".dropped-items-size-cache-ticks", 120, """
                How long in ticks a dropped item's size should be cached after\s
                checking.""")) * 50L;
        this.inventorySizeCacheMillis = Math.max(1, config.getInt(configPath + ".player-inventory-size-cache-ticks", 20, """
                How long in ticks a player's inventory size should be cached after\s
                checking.""")) * 50L;
    }

    @Override
    public void enable() {
        cachedItemSizes = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(itemSizeCacheMillis)).build();
        cachedInventorySizes = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(inventorySizeCacheMillis)).build();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (cachedItemSizes != null) {
            cachedItemSizes.invalidateAll();
            cachedItemSizes.cleanUp();
            cachedItemSizes = null;
        }
        if (cachedInventorySizes != null) {
            cachedInventorySizes.invalidateAll();
            cachedInventorySizes.cleanUp();
            cachedInventorySizes = null;
        }
    }

    @SuppressWarnings("DataFlowIssue") // Legitimate because we make sure no values are null by testing .hasX()
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBookEdit(PlayerEditBookEvent event) {
        BookMeta meta = event.getNewBookMeta();

        if (
                (meta.hasPages() && meta.pages().size() > maxPages)
                || (meta.hasAuthor() && PlainTextComponentSerializer.plainText().serialize(meta.author()).length() > maxAuthorChars)
                || (meta.hasTitle() && PlainTextComponentSerializer.plainText().serialize(meta.title()).length() > maxTitleChars)
        ) {
            event.setCancelled(true);
            return;
        }

        if (ItemUtil.getApproximateByteSize(meta, useUTF16) > maxBookSize) {
            event.setCancelled(true);

            if (kickOnBigBook) {
                final Player player = event.getPlayer();
                player.kick(AnarchyExploitFixes.translation(player.locale()).misc_MaskedKickMessage);
            }
        }
    }

    // Don't spawn oversized items as just the item dropping can kick a player as well
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onItemSpawn(ItemSpawnEvent event) {
        // Check if item is over the size limit
        final Item item = event.getEntity();
        Integer itemSize = cachedItemSizes.get(item.getUniqueId(),
                k -> ItemUtil.getApproximateByteSize(item.getItemStack(), useUTF16));
        // If item is bigger than allowed, don't drop
        if (itemSize > maxItemSize) {
            event.setCancelled(true);
        }
    }

    // Attempt to stop players from picking up large items
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        // Check if item is generally over the size limit
        final Item item = event.getItem();
        Integer itemSize = this.cachedItemSizes.get(item.getUniqueId(),
                k -> ItemUtil.getApproximateByteSize(item.getItemStack(), useUTF16));
        // If item is bigger than allowed, disallow player picking it up
        if (itemSize > maxItemSize) {
            event.setCancelled(true);
            return;
        }

        // Check if the total inventory size would be larger than the maximum inventory size
        final Player player = event.getPlayer();
        // If picking up item would exceed max inventory size, disallow player picking it up
        if (itemSize + cachedInventorySizes.get(player.getUniqueId(),
                k -> ItemUtil.getApproximateByteSize(player.getInventory(), useUTF16)) > maxInventorySize) {
            event.setCancelled(true);
        }
    }

    private void sanitizeInventory(Iterable<ItemStack> inventory) {
        for (ItemStack item : inventory) {
            if (ItemUtil.getApproximateByteSize(item, useUTF16) > maxItemSize) {
                item.setAmount(0);
            }
        }
    }

    // Attempt to clear off big items from affected players
    @EventHandler(priority = EventPriority.LOW)
    private void onJoin(PlayerJoinEvent event) {
        this.sanitizeInventory(event.getPlayer().getInventory());
    }

    @EventHandler(priority = EventPriority.LOW)
    private void onLeave(PlayerQuitEvent event) {
        this.sanitizeInventory(event.getPlayer().getInventory());
    }

    @EventHandler(priority = EventPriority.LOW)
    private void onKick(PlayerKickEvent event) {
        this.sanitizeInventory(event.getPlayer().getInventory());
    }
}