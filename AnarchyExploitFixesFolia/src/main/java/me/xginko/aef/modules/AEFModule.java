package me.xginko.aef.modules;

import com.google.common.collect.ImmutableSet;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.config.Config;
import me.xginko.aef.modules.packets.PacketModule;
import me.xginko.aef.utils.models.ConditionalEnableable;
import me.xginko.aef.utils.models.Disableable;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.config.Configurator;
import org.reflections.Reflections;
import org.reflections.scanners.Scanners;

import java.lang.reflect.Modifier;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

public abstract class AEFModule implements ConditionalEnableable, Disableable {

    protected static final Set<Class<AEFModule>> AVAILABLE_MODULES;
    protected static final Set<AEFModule> ENABLED_MODULES;

    static {
        // Disable reflection logging for this operation because its just confusing and provides no value.
        Configurator.setLevel(AEFModule.class.getPackage().getName() + ".libs.reflections.Reflections", Level.OFF);
        AVAILABLE_MODULES = new Reflections(AEFModule.class.getPackage().getName())
                .get(Scanners.SubTypes.of(AEFModule.class).asClass())
                .stream()
                .filter(clazz -> !clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers()))
                .map(clazz -> (Class<AEFModule>) clazz)
                .sorted(Comparator.comparing(Class::getSimpleName))
                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableSet::copyOf));
        ENABLED_MODULES = new HashSet<>();
    }

    protected final AnarchyExploitFixes plugin;
    protected final Config config;
    protected final String configPath, logFormat;

    public AEFModule(String configPath) {
        this.plugin = AnarchyExploitFixes.getInstance();
        this.config = AnarchyExploitFixes.config();
        this.configPath = configPath;
        shouldEnable(); // Ensure enable option is always first
        String[] paths = configPath.split("\\.");
        if (paths.length <= 2) {
            this.logFormat = "<" + configPath + "> {}";
        } else {
            this.logFormat = "<" + paths[paths.length - 2] + "." + paths[paths.length - 1] + "> {}";
        }
    }

    public static void disableAll() {
        ENABLED_MODULES.forEach(Disableable::disable);
        ENABLED_MODULES.clear();
    }

    public static void reloadModules() {
        disableAll();

        for (Class<AEFModule> moduleClass : AVAILABLE_MODULES) {
            try {
                AEFModule module = moduleClass.getDeclaredConstructor().newInstance();
                if (module.shouldEnable()) {
                    if (module instanceof PacketModule && AnarchyExploitFixes.config().packets_disabled) {
                        module.warn("Cannot enable because you disabled packets in config!");
                        continue;
                    }

                    ENABLED_MODULES.add(module);
                }
            } catch (Throwable t) { // We want to catch everything here if it fails to init
                AnarchyExploitFixes.getPrefixedLogger().warn("Failed initialising module class '{}'.", moduleClass.getSimpleName(), t);
            }
        }
    }

    protected void error(String message, Throwable throwable) {
        AnarchyExploitFixes.getPrefixedLogger().error(logFormat, message, throwable);
    }

    protected void error(String message) {
        AnarchyExploitFixes.getPrefixedLogger().error(logFormat, message);
    }

    protected void warn(String message) {
        AnarchyExploitFixes.getPrefixedLogger().warn(logFormat, message);
    }

    protected void info(String message) {
        AnarchyExploitFixes.getPrefixedLogger().info(logFormat, message);
    }

    protected void notRecognized(Class<?> clazz, String unrecognized) {
        warn("Unable to parse " + clazz.getSimpleName() + " at '" + unrecognized + "'. Please check your configuration.");
    }
}
