package me.xginko.aef.modules.illegals.items;

import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.event.player.PrePlayerAttackEntityEvent;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.enums.IllegalHandling;
import me.xginko.aef.enums.ItemLegality;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.CachingPermTool;
import me.xginko.aef.utils.EntityUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ExpiringSet;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockDispenseEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryInteractEvent;
import org.bukkit.event.inventory.InventoryMoveItemEvent;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.event.player.PlayerAttemptPickupItemEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerItemConsumeEvent;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.checkerframework.checker.nullness.qual.PolyNull;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

public abstract class IllegalItemModule extends AEFModule implements Listener {

    public abstract ItemLegality legalityOf(ItemStack itemStack);
    public abstract void handleItem(ItemStack itemStack, ItemLegality legality);

    protected final AEFPermission bypassPermission;
    protected final IllegalHandling handling;
    protected final Set<Listener> optionalListeners;
    private final boolean guiPluginsSupported;
    private final Cache<Class<? extends Event>, ExpiringSet<Object>> listenerCooldowns;
    private final Function<Class<? extends Event>, @PolyNull ExpiringSet<Object>> createIfAbsent;

    public IllegalItemModule(String configPath, AEFPermission bypassPermission) {
        super(configPath);
        this.bypassPermission = bypassPermission;
        this.optionalListeners = new HashSet<>();
        this.guiPluginsSupported = config.getBoolean(configPath + ".gui-plugins-supported", false, """
                Enable this if you have problems with the plugin removing items from chest guis.
                Check if the inventory is connected to a location in the game.
                If it is not, its very likely created by custom gui plugin.              
                """);
        String configuredHandling = config.getString(configPath + ".handling", IllegalHandling.PREVENT_USE_ONLY.name(),
                "Available options:\n" + Arrays.stream(IllegalHandling.values())
                        .map(option -> option.name() + " - " + option.description())
                        .collect(Collectors.joining("\n")));
        IllegalHandling handling;
        try {
            handling = IllegalHandling.valueOf(configuredHandling);
        } catch (IllegalArgumentException e) {
            handling = IllegalHandling.PREVENT_USE_ONLY;
            warn("Handling option '" + configuredHandling + "' not recognized. Defaulting to " + handling.name());
        }
        this.handling = handling;

        final boolean guiPluginsSupported = config.getBoolean(configPath + ".gui-plugins-supported", false, """
                Enable this if you have problems with the plugin removing items from chest guis.
                Check if the inventory is connected to a location in the game.
                If it is not, its very likely created by custom gui plugin.""");
        if (this.handling == IllegalHandling.STRICT) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onInventoryOpen(InventoryOpenEvent event) {
                    if (CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) return;
                    // Check if the inventory is connected to a location in the game. If it is not,
                    // its very likely created by custom gui plugin
                    if (!guiPluginsSupported || event.getInventory().getLocation() != null) {
                        for (ItemStack invItem : event.getInventory()) {
                            handleItem(invItem, legalityOf(invItem));
                        }
                    }
                }
            });
        }

        if (config.getBoolean(configPath + ".prevent-hopper32k-mechanic", false, """
                Prevents Hopper32k mechanic of placing a shulker containing illegals\s
                on top of a hopper, then using the illegal out of the hoppers inventory.\s
                WARNING: Hooks into InventoryMoveItemEvent, which can become VERY resource\s
                intense as the event fires for every single item getting moved by the\s
                hopper. Enable only if you need to.""")) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onItemGoesThroughHopper(InventoryMoveItemEvent event) {
                    if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
                        event.setCancelled(true);
                    }
                }
            });
        }

        final boolean checkOnChunkload = config.getBoolean(configPath + ".check-on-chunkload.enable", false, """
                WARNING: CHECKING ON CHUNKLOAD IS NOT RECOMMENDED AS IT IS VERY RESOURCE INTENSE.\s
                BE VERY SURE YOU ACTUALLY NEED THIS.\s
                Iterates over all blocks in a chunk when it is loaded and checks any inventories\s
                for illegals. If a container with illegals is found, it will be REMOVED.""");
        final boolean removeContainers = config.getBoolean(configPath + ".check-on-chunkload.remove-container", false, """
                If set to true, immediately replaces the container with air. Otherwise, will try\s
                to handle items separately.""");
        if (checkOnChunkload) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onChunkLoad(ChunkLoadEvent event) {
                    if (event.isNewChunk()) return;

                    Chunk chunk = event.getChunk();
                    final int minY = event.getWorld().getMinHeight();
                    final int maxY = event.getWorld().getMaxHeight();

                    for (int x = 0; x < 16; x++) {
                        for (int z = 0; z < 16; z++) {
                            for (int y = minY; y < maxY; y++) {
                                Block block = chunk.getBlock(x, y, z);
                                if (!MaterialUtil.INVENTORY_HOLDER_ITEMS.contains(block.getType())) continue;

                                if (removeContainers) {
                                    if (legalityOf(((InventoryHolder) block.getState()).getInventory()) != ItemLegality.LEGAL)
                                        block.setType(Material.AIR, false);
                                } else {
                                    BlockState blockState = block.getState(false);
                                    for (ItemStack itemStack : ((InventoryHolder) blockState).getInventory())
                                        handleItem(itemStack, legalityOf(itemStack));
                                    blockState.update(true, false);
                                }
                            }
                        }
                    }
                }
            });
        }

        this.listenerCooldowns = Caffeine.newBuilder().expireAfterWrite(Duration.ofMinutes(5)).build();
        this.createIfAbsent = k -> new ExpiringSet<>(Duration.ofMillis(
                config.getInt(configPath+".check-rate-limit-millis", 3000, """
                        The time in milliseconds to wait before performing another check,\s
                        if a check was positive. Helps with lag resulting from repeatedly\s
                        checking illegals.""")
        ));
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        optionalListeners.forEach(optional -> plugin.getServer().getPluginManager().registerEvents(optional, plugin));
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        optionalListeners.forEach(HandlerList::unregisterAll);
        optionalListeners.clear();
    }

    public ItemLegality legalityOf(Iterable<ItemStack> itemStacks) {
        if (itemStacks == null) {
            return ItemLegality.LEGAL;
        }

        for (ItemStack itemStack : itemStacks) {
            if (legalityOf(itemStack) != ItemLegality.LEGAL) {
                return ItemLegality.CONTAINS_ILLEGAL;
            }
        }

        return ItemLegality.LEGAL;
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerItemConsume(PlayerItemConsumeEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onBlockDispense(BlockDispenseEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getBlock().getLocation())) {
            event.setCancelled(true);
            return;
        }

        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getBlock().getLocation());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerArmorChange(PlayerArmorChangeEvent event) {
        if (!CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            handleItem(event.getNewItem(), legalityOf(event.getNewItem()));
            handleItem(event.getOldItem(), legalityOf(event.getOldItem()));
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onInventoryClick(InventoryClickEvent event) {
        if (CachingPermTool.hasPermission(bypassPermission, event.getWhoClicked())) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getWhoClicked().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemLegality clickedLegality = legalityOf(event.getCurrentItem());
        if (clickedLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCurrentItem(), clickedLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
        }

        ItemLegality cursorLegality = legalityOf(event.getCursor());
        if (cursorLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCursor(), cursorLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onInventoryInteract(InventoryInteractEvent event) {
        if (CachingPermTool.hasPermission(bypassPermission, event.getWhoClicked())) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getWhoClicked().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        for (ItemStack invItem : event.getInventory()) {
            ItemLegality invItemLegality = legalityOf(invItem);
            if (invItemLegality != ItemLegality.LEGAL) {
                event.setCancelled(true);
                handleItem(invItem, invItemLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPrePlayerAttackEntity(PrePlayerAttackEntityEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack mainHandItem = event.getPlayer().getInventory().getItemInMainHand();
        final ItemLegality mainHandLegality = legalityOf(mainHandItem);
        if (mainHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(mainHandItem, mainHandLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }

        ItemStack offHandItem = event.getPlayer().getInventory().getItemInOffHand();
        final ItemLegality offHandLegality = legalityOf(offHandItem);
        if (offHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(offHandItem, offHandLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (event.getDamager().getType() == EntityType.PLAYER) {
            final Player player = (Player) event.getDamager();

            if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(player.getUniqueId())) {
                event.setCancelled(true);
                return;
            }

            ItemStack mainHandItem = player.getInventory().getItemInMainHand();
            final ItemLegality mainHandLegality = legalityOf(mainHandItem);
            if (mainHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, player)) {
                event.setCancelled(true);
                handleItem(mainHandItem, mainHandLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(player.getUniqueId());
            }

            ItemStack offHandItem = player.getInventory().getItemInOffHand();
            final ItemLegality offHandLegality = legalityOf(offHandItem);
            if (offHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, player)) {
                event.setCancelled(true);
                handleItem(offHandItem, offHandLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(player.getUniqueId());
            }
            return;
        }

        if (EntityUtil.isInventoryHolder(event.getDamager())) {
            if (legalityOf(((InventoryHolder) event.getDamager()).getInventory()) != ItemLegality.LEGAL) {
                event.setCancelled(true);
                event.getDamager().getScheduler().execute(plugin, event.getDamager()::remove, null, 1L);
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack pickUpItem = event.getItem().getItemStack();
        final ItemLegality legality = legalityOf(pickUpItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(pickUpItem, legality);
            event.getItem().setItemStack(pickUpItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerDropItem(PlayerDropItemEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack droppedItem = event.getItemDrop().getItemStack();
        final ItemLegality legality = legalityOf(droppedItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            handleItem(droppedItem, legality);
            event.getItemDrop().setItemStack(droppedItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerInteract(PlayerInteractEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack interactItem = event.getItem();
        final ItemLegality legality = legalityOf(interactItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(interactItem, legality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerInteractEntity(PlayerInteractEntityEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack handItem = event.getPlayer().getInventory().getItem(event.getHand());
        final ItemLegality legality = legalityOf(handItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(handItem, legality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }
}
