package me.xginko.aef.modules.lagpreventions;

import com.cryptomorin.xseries.XEntityType;
import com.cryptomorin.xseries.XMaterial;
import com.destroystokyo.paper.MaterialTags;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ChunkUID;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockExplodeEvent;
import org.bukkit.event.entity.EntityExplodeEvent;

import java.time.Duration;
import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class StashExplosions extends AEFModule implements Listener {

    private final Set<Material> storageTypes;
    private final long waitTimeSeconds;
    private final int amountAtWhichToTakeAction;
    private final boolean logIsEnabled;

    private Cache<ChunkUID, Integer> containerExplosions;

    public StashExplosions() {
        super("lag-preventions.disable-item-drops-during-large-stash-explosions", false, """
                Explodes containers without dropping items after a certain amount\s
                of exploded containers per chunk.""");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.amountAtWhichToTakeAction = config.getInt(configPath + ".min-explosions-before-drops-disable", 6, """
                How many container blocks in a chunk can be blown up until items\s
                no longer drop from them.""");
        this.waitTimeSeconds = Math.max(1, config.getInt(configPath + ".time-in-seconds", 3, """
                The time in seconds to wait after an explosion for another one to happen.\s
                If no explosion happens within x seconds after the first one, the count resets to 0."""));
        this.storageTypes = config.getList(configPath + ".container-types", MaterialUtil.INVENTORY_HOLDERS
                        .stream()
                        .filter(material -> !MaterialTags.SHULKER_BOXES.isTagged(material))
                        .map(Enum::name)
                        .collect(Collectors.toList()))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
    }

    @Override
    public void enable() {
        containerExplosions = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(waitTimeSeconds)).build();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (containerExplosions != null) {
            containerExplosions.invalidateAll();
            containerExplosions.cleanUp();
            containerExplosions = null;
        }
    }

    private void handleExplosion(Chunk chunk, List<Block> affectedBlocks) {
        final ChunkUID chunkUID = ChunkUID.of(chunk);
        int containerExplosionsInChunk = containerExplosions.get(chunkUID, k -> 0);

        if (containerExplosionsInChunk > amountAtWhichToTakeAction) {
            if (logIsEnabled) info(
                    "Not dropping contents of storage block(s) affected by explosion at chunk " +
                    "x:" + chunk.getX() + ", z:" + chunk.getZ() + " because more than " + amountAtWhichToTakeAction +
                    " containers have already exploded within the configured timeframe.");

            affectedBlocks.removeIf(block -> {
                if (storageTypes.contains(block.getType())) {
                    block.setType(XMaterial.AIR.get());
                    return true;
                }
                return false;
            });

            return;
        }

        for (Block toExplode : affectedBlocks) {
            if (storageTypes.contains(toExplode.getType())) {
                containerExplosionsInChunk++;
            }
        }

        containerExplosions.put(chunkUID, containerExplosionsInChunk);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBlockExplode(BlockExplodeEvent event) {
        handleExplosion(event.getBlock().getChunk(), event.blockList());
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onEntityExplode(EntityExplodeEvent event) {
        if (event.getEntityType() == XEntityType.WIND_CHARGE.get()) return;
        if (event.getEntityType() == XEntityType.BREEZE_WIND_CHARGE.get()) return;

        handleExplosion(event.getEntity().getChunk(), event.blockList());
    }
}
