package me.xginko.aef.modules.lagpreventions.regionalactivity;

import com.cryptomorin.xseries.XEntityType;
import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.xginko.aef.utils.LocationUtil;
import org.bukkit.GameMode;
import org.bukkit.entity.EntityType;
import org.bukkit.event.entity.EntityEvent;

import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;

/**
 *  Credits to the initial idea of measuring burst activity within a certain region
 *  of the world go to kumori (Soft1k) of 3b3t.org.
 */
public abstract class RegionalEntityActivityModule extends RegionalActivityModule {

    protected final Map<EntityType, Integer> typedActivityLimit = new EnumMap<>(EntityType.class);

    public RegionalEntityActivityModule(
            String subConfigPath, boolean defEnabled, boolean deflogEnabled, int totalLimit, double defCheckRadius,
            int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT,
            Map<XEntityType, Integer> defaultTypeSettings
    ) {
        this(subConfigPath, defEnabled, deflogEnabled, totalLimit, defCheckRadius, defPauseMillis, defCacheMillis,
                defPauseTPS, defPauseMSPT, defaultTypeSettings, null);
    }

    public RegionalEntityActivityModule(
            String subConfigPath, boolean defEnabled, boolean deflogEnabled, int totalLimit,
            double defCheckRadius, int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT,
            Map<XEntityType, Integer> defaultTypeSettings, String comment) {
        super(subConfigPath, defEnabled, deflogEnabled, totalLimit, defCheckRadius, defPauseMillis, defCacheMillis, defPauseTPS, defPauseMSPT, comment);
        Map<String, Object> defaultKV = new HashMap<>(defaultTypeSettings.size());
        for (Map.Entry<XEntityType, Integer> entry : defaultTypeSettings.entrySet()) {
            if (entry.getKey().isSupported()) {
                defaultKV.put(entry.getKey().get().name(), entry.getValue());
            }
        }
        ConfigSection typedSection = config.getConfigSection(configPath + ".typed-limits", defaultKV);
        for (String configuredEntity : typedSection.getKeys(false)) {
            try {
                typedActivityLimit.put(EntityType.valueOf(configuredEntity), Integer.parseInt(typedSection.getString(configuredEntity)));
            } catch (NumberFormatException e) {
                notRecognized(Integer.class, typedSection.getString(configuredEntity));
            }catch (IllegalArgumentException e) {
                notRecognized(GameMode.class, configuredEntity);
            }
        }
    }

    protected <T extends EntityEvent> boolean shouldCancelEntityEvent(T entityEvent) {
        return shouldCancelEvent(entityEvent, entityEvent.getEntity().getLocation()) || shouldCancelBecauseTypeActivity(entityEvent);
    }

    protected <T extends EntityEvent> boolean shouldCancelBecauseTypeActivity(T entityEvent) {
        if (!typedActivityLimit.containsKey(entityEvent.getEntity().getType())) {
            return false;
        }

        int typeLimit = typedActivityLimit.get(entityEvent.getEntityType());
        RegionData regionData = getRegionData(entityEvent.getEntity().getLocation());
        RegionData.ActivityData activityData = regionData.getEntityActivityData(entityEvent.getEntityType());

        if (activityData.resumeTimeMillis.get() > System.currentTimeMillis()) {
            if (logIsEnabled) {
                info(   "Cancelling " + entityEvent.getClass().getSimpleName() + " for " + entityEvent.getEntityType().name() +
                        " at " + LocationUtil.toString(entityEvent.getEntity().getLocation()) + " because it exceeded its " +
                        "activity (limit: " + typeLimit + ").");
            }
            return true;
        }

        if (activityData.activityCount.incrementAndGet() > typeLimit) {
            if (logIsEnabled) {
                warn(   "Disabling " + entityEvent.getEntityType().name() + " in a radius of " + checkRadius +
                        " blocks from center at x=" + regionData.region.getCenterX() + ", z=" + regionData.region.getCenterZ() +
                        " in world " + entityEvent.getEntity().getWorld().getName() + " for " + pauseTimeMillis + "ms, " +
                        "because of too high activity within the configured timeframe: " +
                        activityData.activityCount + " (limit: " + typeLimit + ")");
            }
            activityData.resumeTimeMillis.set(System.currentTimeMillis() + pauseTimeMillis);
            activityData.activityCount.set(0); // Reset count when region is cooling down
            return true;
        }

        return false;
    }
}
