package me.xginko.aef.modules.dupepreventions;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.manager.server.ServerVersion;
import com.github.retrooper.packetevents.netty.buffer.ByteBufHelper;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import me.xginko.aef.modules.packets.PacketModule;
import me.xginko.aef.utils.PlatformUtil;

import java.nio.charset.StandardCharsets;

public class BookTitleDupe extends PacketModule {

    private final int titleLimit, pageLimit, pageCharLimit;
    private final boolean log, kick;

    public BookTitleDupe() {
        super("dupe-preventions.book-title-dupe", true, PacketListenerPriority.HIGHEST,"""
                Relevant for 1.20.6 - 1.21:
                Will prevent players from sending book packets with a too large title,
                to get disconnected and their inventories restored.""");
        boolean modernLimits = PacketEvents.getAPI().getServerManager().getVersion().isNewerThanOrEquals(ServerVersion.V_1_21_2);
        this.titleLimit = config.getInt(configPath + ".max-title-charlength", modernLimits ? 32 : 128);
        this.pageLimit = config.getInt(configPath + ".max-pages", modernLimits ? 100 : 200);
        this.pageCharLimit = config.getInt(configPath + ".max-page-charlength", modernLimits ? 1024 : 8192);
        this.log = config.getBoolean(configPath + ".log", false);
        this.kick = config.getBoolean(configPath + ".kick-player", false);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", PlatformUtil.getMinecraftPatchVersion() > 19);
    }

    @Override
    public void onPacketReceive(PacketReceiveEvent event) {
        if (event.getPacketType() != PacketType.Play.Client.EDIT_BOOK) return;

        if (isIllegalBookEdit(event)) {
            event.setCancelled(true);
            onCancel(log, kick, event.getUser());
        }
    }

    private boolean isIllegalBookEdit(PacketReceiveEvent event) {
        int slot = ByteBufHelper.readVarInt(event.getByteBuf());

        int pageCount = ByteBufHelper.readVarInt(event.getByteBuf());

        if (pageCount > pageLimit) {
            return true;
        }

        for (int i = 0; i < pageCount; ++i) {
            if (isStringTooBig(event.getByteBuf(), pageCharLimit)) {
                return true;
            }
        }

        if (ByteBufHelper.readByte(event.getByteBuf()) != 0) {
            return isStringTooBig(event.getByteBuf(), titleLimit);
        }

        return false;
    }

    private boolean isStringTooBig(Object byteBuf, int charLimit) {
        int strBufLen = ByteBufHelper.readVarInt(byteBuf);

        // Check if the received encoded string buffer length is shorter or longer than allowed
        if (strBufLen < 0 || strBufLen > charLimit * 4) {
            return true;
        }

        // The received string length is longer than maximum allowed
        return ByteBufHelper.toString(byteBuf, ByteBufHelper.readerIndex(byteBuf), strBufLen, StandardCharsets.UTF_8)
                .length() > charLimit;
    }
}
