package me.xginko.aef.modules.lagpreventions;

import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ChunkUID;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.BlockState;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.util.NumberConversions;

import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class KeepStashLoaded extends AEFModule implements Consumer<ScheduledTask>, Listener {

    private final Map<ChunkUID, Long> forceLoadedChunks;
    private final Map<String, Double> worldsAndTheirRadiuses = new HashMap<>();
    private final Set<Material> storageTypes;
    private final long minInhabitedTime, keepLoadedMillis;
    private final int stashCount;
    private final boolean logIsEnabled, onlyTileEntities;

    public KeepStashLoaded() {
        super("lag-preventions.keep-stash-chunks-loaded");
        this.forceLoadedChunks = new ConcurrentHashMap<>();
        config.addComment(configPath + ".enable", """
                Idea by 6g6s admin kumorio:\s
                Improves lag generated by large stash chunks constantly loading and\s
                unloading by setting them force loaded. This might cause increased ram\s
                usage, so keep an eye out for that.""");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.stashCount = config.getInt(configPath + ".container-block-threshold", 50, """
                How many container blocks have to be in a chunk for it to be seen\s
                as a stash chunk to keep force loaded.""");
        this.minInhabitedTime = config.getInt(configPath + ".min-chunk-inhabited-time-ticks", 1000, """
                The minimum time in ticks a chunk has to have been inhabited to be checked.""");
        this.keepLoadedMillis = TimeUnit.MINUTES.toMillis(config.getInt(configPath + ".keep-loaded-minutes", 120, """
                The time in minutes a stash chunks will be kept force loaded before\s
                setting it back to normal."""));
        this.onlyTileEntities = config.getBoolean(configPath + ".only-check-tile-entities", true, """
                Set to false if you want to check more blocks than just tile entities.\s
                Makes the overall speed of the module faster if set to true.""");
        this.storageTypes = config.getList(configPath + ".container-types", MaterialUtil.INVENTORY_HOLDER_ITEMS
                        .stream()
                        .map(Enum::name)
                        .collect(Collectors.toList()))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
        Map<String, Object> defaults = new HashMap<>();
        defaults.put("world", 100);
        defaults.put("world_nether", 100);
        defaults.put("world_the_end", 100);
        ConfigSection section = config.getConfigSection(configPath + ".worlds", defaults,
                "Radiuses around spawn in chunks (not blocks) that should not be checked.\n" +
                        "Worlds not on this list are exempt from all checking.");
        for (String world : section.getKeys(false)) {
            try {
                int radius = Integer.parseInt(section.getString(world));
                this.worldsAndTheirRadiuses.put(world, NumberConversions.square(radius));
            } catch (NumberFormatException e) {
                warn("Radius for world '" + world + "' is not a valid integer.");
            }
        }
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        plugin.getServer().getAsyncScheduler().runAtFixedRate(plugin, this, 1L, 1L, TimeUnit.MINUTES);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            entry.getKey().getChunkAsync(false).thenAccept(chunk -> {
                if (chunk != null)
                    plugin.getServer().getGlobalRegionScheduler().execute(plugin, () -> chunk.setForceLoaded(false));
                forceLoadedChunks.remove(entry.getKey());
            });
        }
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void accept(ScheduledTask task) {
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            if (System.currentTimeMillis() < entry.getValue()) {
                continue;
            }

            entry.getKey().getChunkAsync(false).thenAccept(chunk -> {
                if (chunk == null) {
                    forceLoadedChunks.remove(entry.getKey());
                    if (logIsEnabled)
                        info("Removing key that returned a null chunk: "+entry.getKey()+".");
                    return;
                }

                plugin.getServer().getGlobalRegionScheduler().execute(plugin, () -> {
                    chunk.setForceLoaded(false);
                    forceLoadedChunks.remove(entry.getKey());
                    if (logIsEnabled)
                        info("Set chunk "+entry.getKey()+" to no longer force loaded.");
                });
            });
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onChunkLoad(ChunkLoadEvent event) {
        if (event.isNewChunk()) return;
        final String world = event.getWorld().getName();
        if (!worldsAndTheirRadiuses.containsKey(world)) return;

        Chunk chunk = event.getChunk();

        if (chunk.getInhabitedTime() < minInhabitedTime) return;
        if (NumberConversions.square(chunk.getX()) + NumberConversions.square(chunk.getZ()) < worldsAndTheirRadiuses.get(world)) return;

        if (isStashChunk(chunk)) {
            forceLoadedChunks.computeIfAbsent(ChunkUID.of(chunk), chunkUID -> {
                plugin.getServer().getGlobalRegionScheduler().execute(plugin, () -> {
                    chunk.setForceLoaded(true);
                    if (logIsEnabled)
                        info("Set chunk " + chunkUID + " to force loaded.");
                });
                return System.currentTimeMillis() + keepLoadedMillis;
            });
        }
    }

    private boolean isStashChunk(Chunk chunk) {
        int count = 0;

        if (onlyTileEntities) {
            for (BlockState tileEntity : chunk.getTileEntities()) {
                if (storageTypes.contains(tileEntity.getType())) {
                    count++;
                    if (count > stashCount) {
                        return true;
                    }
                }
            }
        } else {
            final int minY = chunk.getWorld().getMinHeight();
            final int maxY = chunk.getWorld().getMaxHeight();

            for (int x = 0; x < 16; x++) {
                for (int z = 0; z < 16; z++) {
                    for (int y = minY; y < maxY; y++) {
                        if (storageTypes.contains(chunk.getBlock(x, y, z).getType())) {
                            count++;
                            if (count > stashCount) {
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }
}
