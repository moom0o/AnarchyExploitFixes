package me.xginko.aef.modules.lagpreventions;

import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ChunkUID;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.world.ChunkLoadEvent;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class KeepStashLoaded extends AEFModule implements Consumer<ScheduledTask>, Listener {

    private final Map<ChunkUID, Long> forceLoadedChunks;
    private final Set<Material> storageTypes;
    private final long minInhabitedTime, keepLoadedMillis;
    private final int stashCount;
    private final boolean logIsEnabled;
    private final Map<String, Integer> worldsAndTheirRadiuses = new HashMap<>();

    public KeepStashLoaded() {
        super("lag-preventions.keep-stash-chunks-loaded");
        this.forceLoadedChunks = new ConcurrentHashMap<>();
        config.addComment(configPath + ".enable", """
                Idea by 6g6s admin kumori:\s
                Improves lag generated by large stash chunks constantly loading and\s
                unloading by setting them force loaded. This might cause increased ram\s
                usage, so keep an eye out for that.""");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.stashCount = config.getInt(configPath + ".container-block-threshold", 50, """
                How many container blocks have to be in a chunk for it to be seen\s
                as a stash chunk to keep force loaded.""");
        this.minInhabitedTime = config.getInt(configPath + ".min-chunk-inhabited-time-ticks", 1000, """
                The minimum time in ticks a chunk has to have been inhabited to be checked.""");
        this.keepLoadedMillis = TimeUnit.MINUTES.toMillis(config.getInt(configPath + ".keep-loaded-minutes", 60, """
                The time in minutes a stash chunks will be kept force loaded before\s
                setting it back to normal."""));
        this.storageTypes = config.getList(configPath + ".container-types", MaterialUtil.INVENTORY_HOLDER_BLOCKS
                        .stream()
                        .map(Enum::name)
                        .collect(Collectors.toList()))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

        Map<String, Object> defaults = new HashMap<>();
        defaults.put("world", 5000);
        defaults.put("world_nether", 5000);
        defaults.put("world_the_end", 5000);
        ConfigSection section = config.getConfigSection(configPath + ".worlds", defaults, "Spawn radius in which stashes should not be checked");
        for (String world : section.getKeys(false)) {
            try {
                Integer radius = Integer.valueOf(section.getString(world));
                this.worldsAndTheirRadiuses.put(world, radius);
            } catch (NumberFormatException e) {
                warn("Radius for world '" + world + "' is not a valid integer.");
            }
        }
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        plugin.getServer().getAsyncScheduler().runAtFixedRate(plugin, this, 1L, 1L, TimeUnit.MINUTES);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            Chunk chunk = entry.getKey().getChunk();
            if (chunk != null)
                plugin.getServer().getGlobalRegionScheduler().execute(plugin, () -> chunk.setForceLoaded(false));
            forceLoadedChunks.remove(entry.getKey());
        }
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void accept(ScheduledTask task) {
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            if (System.currentTimeMillis() < entry.getValue()) {
                continue;
            }

            Chunk chunk = entry.getKey().getChunk();
            if (chunk == null) {
                forceLoadedChunks.remove(entry.getKey());
                if (logIsEnabled)
                    info("Removing key that returns a null chunk: "+entry.getKey()+".");
                continue;
            }

            plugin.getServer().getGlobalRegionScheduler().execute(plugin, () -> {
                chunk.setForceLoaded(false);
                forceLoadedChunks.remove(entry.getKey());
                if (logIsEnabled)
                    info("Set chunk "+entry.getKey()+" to no longer force loaded.");
            });
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    private void onChunkLoad(ChunkLoadEvent event) {
        if (event.isNewChunk()) return;
        Chunk chunk = event.getChunk();
        if (chunk.getInhabitedTime() < minInhabitedTime) return;

        final String world = chunk.getWorld().getName();
        if (!worldsAndTheirRadiuses.containsKey(world)) return;

        final Integer disabledRadius = worldsAndTheirRadiuses.get(world);
        final Location chunkLocation = chunk.getWorld().getLocationAtKey(chunk.getChunkKey());
        if (LocationUtil.getDistance2DTo00(chunkLocation) < disabledRadius) return;

        final int minY = event.getWorld().getMinHeight();
        final int maxY = event.getWorld().getMaxHeight();

        boolean setForceLoaded = false;

        int count = 0;
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                for (int y = minY; y < maxY; y++) {
                    if (storageTypes.contains(chunk.getBlock(x, y, z).getType())) {
                        count++;
                        if (count > stashCount) {
                            setForceLoaded = true;
                            break;
                        }
                    }
                }
            }
        }

        if (!setForceLoaded) {
            return;
        }

        forceLoadedChunks.computeIfAbsent(ChunkUID.of(chunk), chunkUID -> {
            plugin.getServer().getGlobalRegionScheduler().execute(plugin, () -> {
                chunk.setForceLoaded(true);
                if (logIsEnabled)
                    info("Set chunk "+chunkUID+" to force loaded.");
            });
            return System.currentTimeMillis() + keepLoadedMillis;
        });
    }
}
