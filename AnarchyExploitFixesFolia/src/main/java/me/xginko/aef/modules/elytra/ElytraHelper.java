package me.xginko.aef.modules.elytra;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListener;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.PacketSide;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPlayerFlying;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerChangedWorldEvent;
import org.bukkit.event.player.PlayerKickEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.jetbrains.annotations.NotNull;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public class ElytraHelper extends AEFModule implements Runnable, PacketListener, Listener {

    private static ElytraHelper instance;
    private final Map<UUID, PlayerData> playerDataMap;
    private final PacketListenerAbstract packetListener;
    private ScheduledExecutorService executorService;
    private ScheduledFuture<?> scheduledTask;

    public ElytraHelper() {
        super("elytra.elytra-speed");
        instance = this;
        playerDataMap = new ConcurrentHashMap<>();
        packetListener = asAbstract(PacketListenerPriority.MONITOR);
    }

    public static ElytraHelper getInstance() {
        return instance;
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        PacketEvents.getAPI().getEventManager().registerListener(packetListener);
        executorService = Executors.newScheduledThreadPool(1);
        scheduledTask = executorService.scheduleAtFixedRate(
                this, 50L, config.elytra_speed_calc_period * 50L, TimeUnit.MILLISECONDS);
    }

    @Override
    public boolean shouldEnable() {
        return config.elytra_enable_at_spawn || config.elytra_enable_global || config.elytra_enable_netherceiling;
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        PacketEvents.getAPI().getEventManager().unregisterListener(packetListener);
        if (scheduledTask != null) scheduledTask.cancel(true);
        if (executorService != null) executorService.shutdown();
    }

    @Override
    public void run() {
        for (Map.Entry<UUID, PlayerData> entry : playerDataMap.entrySet()) {
            entry.getValue().calcSpeedAvg(config.elytra_calculate_3D, config.elytra_speed_calc_period);
        }
    }

    @Override
    public void onPacketReceive(PacketReceiveEvent event) {
        if (event.getPacketType().getSide() != PacketSide.CLIENT) return;
        if (event.getUser() == null) return;
        UUID player = event.getUser().getUUID();
        if (player == null || !playerDataMap.containsKey(event.getUser().getUUID())) return;

        if (
                event.getPacketType() == PacketType.Play.Client.PLAYER_FLYING
                || event.getPacketType() == PacketType.Play.Client.PLAYER_POSITION
                || event.getPacketType() == PacketType.Play.Client.PLAYER_POSITION_AND_ROTATION
        ) {
            playerDataMap.get(player).updateLatestPosition(new WrapperPlayClientPlayerFlying(event).getLocation());
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onWorldChange(PlayerChangedWorldEvent event) {
        if (playerDataMap.containsKey(event.getPlayer().getUniqueId())) {
            playerDataMap.get(event.getPlayer().getUniqueId()).updateLatestPosition(event.getPlayer().getLocation());
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onPlayerMove(PlayerMoveEvent event) {
        if (event.getPlayer().isGliding()) {
            playerDataMap.computeIfAbsent(event.getPlayer().getUniqueId(), k -> new PlayerData(event.getFrom(), event.getTo()));
        } else {
            playerDataMap.remove(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onPlayerQuit(PlayerQuitEvent event) {
        playerDataMap.remove(event.getPlayer().getUniqueId());
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onPlayerKick(PlayerKickEvent event) {
        playerDataMap.remove(event.getPlayer().getUniqueId());
    }

    public double getBlocksPerTick(PlayerMoveEvent event) {
        return playerDataMap.computeIfAbsent(event.getPlayer().getUniqueId(),
                k -> new PlayerData(event.getFrom(), event.getTo())).getSpeedAvg();
    }

    public boolean isInNewChunks(Player player) {
        return player.getChunk().getInhabitedTime() <= 200L;
    }

    public Location getSetbackLocation(PlayerMoveEvent event) {
        return playerDataMap.computeIfAbsent(event.getPlayer().getUniqueId(),
                k -> new PlayerData(event.getFrom(), event.getTo())).previous;
    }

    private static class PlayerData {
        public @NotNull Location previous, latest;
        private double speedAvg;

        public PlayerData(@NotNull Location previous, @NotNull Location latest) {
            this.previous = previous;
            this.latest = latest;
        }

        public double getSpeedAvg() {
            return speedAvg;
        }

        public void updateLatestPosition(com.github.retrooper.packetevents.protocol.world.Location location) {
            latest.setX((float) location.getX());
            latest.setY((float) location.getY());
            latest.setZ((float) location.getZ());
        }

        public void updateLatestPosition(Location location) {
            latest.setWorld(location.getWorld());
            latest.setX((float) location.getX());
            latest.setY((float) location.getY());
            latest.setZ((float) location.getZ());
        }

        public void calcSpeedAvg(boolean using3D, long period) {
            speedAvg = Math.abs(using3D ? LocationUtil.getRelDistance3D(previous, latest) : LocationUtil.getRelDistance2D(previous, latest)) / period;
            previous = latest.clone();
        }
    };
}
