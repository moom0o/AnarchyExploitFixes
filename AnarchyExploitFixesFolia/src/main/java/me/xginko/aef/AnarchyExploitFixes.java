package me.xginko.aef;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.manager.server.ServerVersion;
import de.tr7zw.changeme.nbtapi.NBT;
import me.xginko.aef.commands.AEFCommand;
import me.xginko.aef.config.Config;
import me.xginko.aef.config.Translation;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocaleUtil;
import me.xginko.aef.utils.permissions.AEFPermission;
import me.xginko.aef.utils.permissions.PermissionHandler;
import me.xginko.aef.utils.KyoriUtil;
import me.xginko.aef.utils.PlatformUtil;
import me.xginko.aef.utils.tickdata.TickReporter;
import net.kyori.adventure.identity.Identity;
import net.kyori.adventure.pointer.Pointered;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.config.Configurator;
import org.bstats.bukkit.Metrics;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.jar.JarFile;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;

public final class AnarchyExploitFixes extends JavaPlugin {

    private static AnarchyExploitFixes instance;
    private static Map<Locale, Translation> translations;
    private static Config config;

    private static TickReporter tickReporter;
    private static PermissionHandler permissionHandler;
    private static ComponentLogger prefixedLogger, unPrefixedLogger;

    private static Metrics metrics;
    private static boolean isPacketEventsInstalled;

    @Override
    public void onLoad() {
        PlatformUtil.load();
        // Disable info logging for Reflections because it does not provide additional value to the user and makes startup log look ugly.
        Configurator.setLevel(AnarchyExploitFixes.class.getPackage().getName() + ".libs.reflections.Reflections", Level.WARN);
    }

    @Override
    public void onEnable() {
        if (!PlatformUtil.isPaper()) {
            getLogger().severe("This plugin depends on Paper's API, which is not present on your server.");
            getServer().getPluginManager().disablePlugin(this);
            return;
        }

        prefixedLogger = ComponentLogger.logger(getLogger().getName());
        unPrefixedLogger = ComponentLogger.logger("");

        isPacketEventsInstalled = getServer().getPluginManager().getPlugin("packetevents") != null;
        if (!isPacketEventsInstalled) {
            Stream.of("                                                               ",
                    "       _   _   _             _   _                             ",
                    "      / \\ | |_| |_ ___ _ __ | |_(_) ___  _ __                 ",
                    "     / _ \\| __| __/ _ \\ '_ \\| __| |/ _ \\| '_ \\            ",
                    "    / ___ \\ |_| ||  __/ | | | |_| | (_) | | | |               ",
                    "   /_/   \\_\\__|\\__\\___|_| |_|\\__|_|\\___/|_| |_|          ",
                    "                                                               ",
                    "   AEF depends on PacketEvents to function!                    ",
                    "   You can either download the latest release on modrinth:     ",
                    "   https://modrinth.com/plugin/packetevents/                   ",
                    "   or choose a dev build on their jenkins:                     ",
                    "   https://ci.codemc.io/job/retrooper/job/packetevents/        ",
                    "                                                               "
            ).forEach(prefixedLogger::error);
            getServer().shutdown(); // Don't allow plugman/serverutil users to hot-load this plugin if packetevents is missing.
            return;
        }

        Stream.of("                                                          ",
                "                                                          ",
                "     █████  ███████ ███████                               ",
                "    ██   ██ ██      ██             AnarchyExploitFixes    ",
                "    ███████ █████   █████            Made by moom0o       ",
                "    ██   ██ ██      ██             Rewritten by xGinko    ",
                "    ██   ██ ███████ ██                                    ",
                "                                                          ",
                "                                                          "
        ).map(str -> Component.text(str).color(KyoriUtil.AEF_WHITE)).forEach(prefixedLogger::info);

        ServerVersion serverVersion = PacketEvents.getAPI().getServerManager().getVersion();
        prefixedLogger.info("Detected {} {}", PlatformUtil.getServerType().niceName(),
                serverVersion.name().replace("V_", "").replace('_', '.'));
        if (serverVersion.isOlderThan(ServerVersion.V_1_19_4) ||
                (serverVersion.equals(ServerVersion.V_1_19_4) && !PlatformUtil.isFolia())) {
            prefixedLogger.error("This plugin jar is incompatible with your Server. Please use the Legacy jar.");
            getServer().getPluginManager().disablePlugin(this);
            return;
        }

        try {
            Files.createDirectories(getDataFolder().toPath());
        } catch (Exception e) {
            prefixedLogger.error("Unable to create plugin directory.", e);
            getServer().getPluginManager().disablePlugin(this);
            return;
        }

        instance = this;

        prefixedLogger.info("Registering Permissions");
        permissionHandler = PermissionHandler.create(this);
        AEFPermission.registerAll();

        prefixedLogger.info("Loading Config");
        reloadConfiguration();

        prefixedLogger.info("Loading Translations");
        reloadTranslations();

        prefixedLogger.info("Loading NBT-API");
        // Hide all messages with a log level lower than WARNING because of the same reason as Reflections logging.
        Logger.getLogger("NBTAPI").setLevel(java.util.logging.Level.WARNING);
        if (!NBT.preloadApi()) prefixedLogger.error("Error initializing NBT-API! This will break some modules!");

        prefixedLogger.info("Loading Metrics");
        metrics = new Metrics(this, 8700);

        prefixedLogger.info("Done.");
    }

    @Override
    public void onDisable() {
        AEFPermission.unregisterAll();
        if (isPacketEventsInstalled) {
            AEFModule.disableAll();
            AEFCommand.disableAll();
        }
        if (translations != null) {
            translations.clear();
            translations = null;
        }
        if (permissionHandler != null) {
            permissionHandler.disable();
            permissionHandler = null;
        }
        if (tickReporter != null) {
            tickReporter.disable();
            tickReporter = null;
        }
        if (metrics != null) {
            metrics.shutdown();
            metrics = null;
        }
        unPrefixedLogger = null;
        prefixedLogger = null;
        instance = null;
        config = null;
    }

    public static AnarchyExploitFixes getInstance()  {
        return instance;
    }

    public static PermissionHandler permissions() {
        return permissionHandler;
    }

    public static TickReporter tickReporter() {
        return tickReporter;
    }

    public static Config config() {
        return config;
    }

    public static ComponentLogger prefixedLogger() {
        return prefixedLogger;
    }

    public static ComponentLogger unprefixedLogger() {
        return unPrefixedLogger;
    }

    public static Translation translation(Pointered pointered) {
        return translation(pointered.pointers().getOrDefault(Identity.LOCALE, config.default_lang));
    }

    public static Translation translation(Locale locale) {
        if (config.auto_lang) return translations.getOrDefault(locale, translations.get(config.default_lang));
        return translations.get(config.default_lang);
    }

    public void reloadPlugin() {
        reloadConfiguration();
        reloadTranslations();
    }

    private void reloadConfiguration() {
        try {
            config = new Config();
            if (tickReporter != null) tickReporter.disable();
            tickReporter = TickReporter.create(this, config.tickData_cache_duration);
            AEFModule.reloadModules();
            AEFCommand.reloadCommands();
            config.saveConfig();
        } catch (Throwable t) {
            prefixedLogger.error("Failed while loading config!", t);
        }
    }

    public void reloadTranslations() {
        final List<Locale> available = getAvailableTranslations();

        if (available.isEmpty()) {
            prefixedLogger.error("No translations available for loading. Keeping previous translation if there are any.");
        } else {
            Map<Locale, Translation> newTranslations = new HashMap<>(available.size());
            StringBuilder neatlyListedTranslations = new StringBuilder();
            for (int i = 0; i < available.size(); i++) {
                neatlyListedTranslations.append(LocaleUtil.languageTagForLocale(available.get(i)));
                try {
                    newTranslations.put(available.get(i), new Translation(available.get(i)));
                } catch (Exception e) {
                    neatlyListedTranslations.append("(error)");
                }

                if (i < available.size() - 1)
                    neatlyListedTranslations.append(", ");
                if ((i + 1) % 4 == 0 || i == available.size() - 1) {
                    prefixedLogger.info(neatlyListedTranslations.toString());
                    neatlyListedTranslations.setLength(0); // Clear StringBuilder for next line
                }
            }

            // Make sure we were able to parse at least one translation before applying new translations
            if (!newTranslations.isEmpty()) {
                if (newTranslations.containsKey(config.default_lang)) { // Ensure default lang is available
                    translations = newTranslations;
                    prefixedLogger.info("Loaded {} translations.", translations.size());
                } else {
                    prefixedLogger.error("Can't find translation for default language '{}'!", config.default_lang);
                }
            }
        }

        // Make sure plugin doesn't enter a state where console gets spammed by exceptions
        if (translations == null || translations.isEmpty()) {
            prefixedLogger.error("Unable to load translations. Disabling.");
            getServer().getPluginManager().disablePlugin(this);
        }
    }

    private @NotNull List<Locale> getAvailableTranslations() {
        try (final JarFile pluginJar = new JarFile(getFile())) {
            Stream<String> fileNames = null;

            File langFolder = new File(getDataFolder(), "/lang");
            if (langFolder.exists()) { // Check if translations can be read from the AnarchyExploitFixes/lang directory
                if (langFolder.isDirectory()) {
                    File[] files = langFolder.listFiles();
                    // If the folder exists and is not empty, look for translations in local source
                    if (files != null && files.length > 0) {
                        fileNames = Arrays.stream(files).map(File::getName);
                    }
                } else {
                    // If there is a file where the lang directory is supposed to be, rename and create new empty folder
                    String newName = langFolder.getPath() + ".non-directory";
                    prefixedLogger.warn("Found weird non-directory file at '{}'. Renaming to '{}'.", langFolder.getPath(), newName);
                    if (!langFolder.renameTo(new File(newName)))
                        throw new FileAlreadyExistsException("Could not rename existing file at lang directory path.");
                    Files.createDirectories(langFolder.toPath());
                }
            } else {
                // Create lang directory if it does not exist
                Files.createDirectories(langFolder.toPath());
            }

            // If directory did not exist or was empty, look for translations in plugin resources
            if (fileNames == null) {
                fileNames = pluginJar.stream().map(ZipEntry::getName);
            }

            // Search sources for translations using regex and parse Locale from filename
            final Pattern langPattern = Pattern.compile("([a-z]{1,3}_[a-z]{1,3})(\\.yml)", Pattern.CASE_INSENSITIVE);
            return fileNames
                    .map(langPattern::matcher)
                    .filter(Matcher::find)
                    .map(matcher -> matcher.group(1))
                    .distinct()
                    .sorted()
                    .map(LocaleUtil::localeForLanguageTag)
                    // If dynamic switching of translations is turned off, remove everything except default language
                    .filter(locale -> config.auto_lang || locale == config.default_lang)
                    .collect(Collectors.toList());
        } catch (IOException e) {
            prefixedLogger.error("Failed while searching for available translations!", e);
            return Collections.emptyList();
        }
    }
}