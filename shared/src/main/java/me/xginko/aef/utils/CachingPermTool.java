package me.xginko.aef.utils;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.utils.models.Disableable;
import org.bukkit.entity.HumanEntity;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerKickEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.plugin.java.JavaPlugin;

import java.time.Duration;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public final class CachingPermTool implements Disableable, Listener {

    private static final Map<UUID, Cache<AEFPermission, Boolean>> permissionCacheMap = new ConcurrentHashMap<>();
    private static final Duration cacheDuration = Duration.ofSeconds(5);

    CachingPermTool(JavaPlugin plugin) {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    public static CachingPermTool enable(JavaPlugin plugin) {
        return new CachingPermTool(plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        for (Map.Entry<UUID, Cache<AEFPermission, Boolean>> entry : permissionCacheMap.entrySet())
            entry.getValue().cleanUp();
        permissionCacheMap.clear();
    }

    public static boolean hasPermission(AEFPermission permission, HumanEntity human) {
        Cache<AEFPermission, Boolean> permCache = permissionCacheMap.computeIfAbsent(human.getUniqueId(),
                k -> Caffeine.newBuilder().expireAfterWrite(cacheDuration).build());
        Boolean hasPermission = permCache.getIfPresent(permission);
        if (hasPermission == null) {
            hasPermission = human.hasPermission(permission.bukkit());
            permCache.put(permission, hasPermission);
        }
        return hasPermission;
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onLeave(PlayerQuitEvent event) {
        permissionCacheMap.remove(event.getPlayer().getUniqueId());
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onKick(PlayerKickEvent event) {
        permissionCacheMap.remove(event.getPlayer().getUniqueId());
    }
}
