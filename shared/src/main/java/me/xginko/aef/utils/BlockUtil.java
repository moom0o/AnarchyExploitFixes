package me.xginko.aef.utils;

import de.tr7zw.changeme.nbtapi.NBT;
import de.tr7zw.changeme.nbtapi.iface.ReadableNBT;
import org.bukkit.Material;
import org.bukkit.block.BlockState;
import org.bukkit.block.data.Waterlogged;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.EnumMap;
import java.util.Map;

public final class BlockUtil {

    private static final boolean WATERLOGGED_AVAILABLE;

    static {
        WATERLOGGED_AVAILABLE = Crafty.hasClass("org.bukkit.block.data.Waterlogged");
    }

    public static boolean isWaterloggedAvailable() {
        return WATERLOGGED_AVAILABLE;
    }

    private static final boolean WATERLOGGED_AVAILABLE;

    static {
        WATERLOGGED_AVAILABLE = Crafty.hasClass("org.bukkit.block.data.Waterlogged");
    }

    public static boolean isWaterloggedAvailable() {
        return WATERLOGGED_AVAILABLE;
    }

    private static final Map<Material, Boolean> IS_WATERLOGGABLE_CACHE = new EnumMap<>(Material.class);
    public static boolean isWaterlogged(@Nullable BlockState blockState) {
        return  blockState != null
                && IS_WATERLOGGABLE_CACHE.computeIfAbsent(blockState.getType(), k -> blockState.getBlockData() instanceof Waterlogged)
                && ((Waterlogged) blockState.getBlockData()).isWaterlogged();
    }

    public static String getNBTString(@NotNull BlockState blockState) {
        return NBT.get(blockState, ReadableNBT::toString);
    }
}
