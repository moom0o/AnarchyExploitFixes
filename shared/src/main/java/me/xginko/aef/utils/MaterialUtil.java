package me.xginko.aef.utils;

import com.cryptomorin.xseries.XMaterial;
import com.cryptomorin.xseries.XTag;
import org.bukkit.Material;
import org.bukkit.SkullType;
import org.bukkit.block.BlockState;
import org.bukkit.block.Skull;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.SkullMeta;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class MaterialUtil {

    public static final Set<Material> INVENTORY_HOLDERS = Arrays.stream(Material.values())
            .filter(Material::isItem) // Prevents loading issues in 1.20.6+
            .map(ItemStack::new)
            .filter(itemStack -> itemStack.getItemMeta() instanceof BlockStateMeta)
            .map(itemStack -> ((BlockStateMeta) itemStack.getItemMeta()).getBlockState())
            .filter(blockState -> blockState instanceof InventoryHolder)
            .map(BlockState::getType)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> LECTERN_BOOKS = XTag.ITEMS_LECTERN_BOOKS.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SIGNS = XTag.SIGNS.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> TRAPDOORS = XTag.TRAPDOORS.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PRESSURE_PLATES = XTag.PRESSURE_PLATES.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SHULKER_BOXES = XTag.SHULKER_BOXES.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> ANVILS = XTag.ANVIL.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> BEDS = XTag.BEDS.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> POTIONS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("POTION"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PISTONS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("PISTON"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SPAWN_EGGS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SPAWN_EGG"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SLAB_LIKE = Stream.concat(
                    Arrays.stream(XMaterial.values()).filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SLAB")),
                    Stream.of(XMaterial.SCULK_SENSOR, XMaterial.CALIBRATED_SCULK_SENSOR, XMaterial.SCULK_SHRIEKER))
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PLAYER_HEADS = Stream.of(
                    XMaterial.PLAYER_HEAD,
                    XMaterial.PLAYER_WALL_HEAD)
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> REDSTONE = Stream.of(
                    XMaterial.REDSTONE,
                    XMaterial.REDSTONE_WIRE)
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    // Blocks that the player gets lowered into slightly when walking on them
    public static final Set<Material> SINK_IN_BLOCKS = Stream.of(
                    XMaterial.SOUL_SAND,
                    XMaterial.FARMLAND,
                    XMaterial.MUD)
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SOLID_INDESTRUCTIBLES = Stream.of(
                    XMaterial.BEDROCK,
                    XMaterial.END_PORTAL_FRAME,
                    XMaterial.REINFORCED_DEEPSLATE,
                    XMaterial.STRUCTURE_BLOCK,
                    XMaterial.STRUCTURE_VOID,
                    XMaterial.BARRIER,
                    XMaterial.COMMAND_BLOCK)
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> INDESTRUCTIBLES = Stream.concat(SOLID_INDESTRUCTIBLES.stream(),
                    Stream.of(XMaterial.END_PORTAL.get()))
            .filter(Objects::nonNull)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> BLOCK_DISPENSE_BUCKETS = Stream.of(
                    XMaterial.WATER_BUCKET,
                    XMaterial.LAVA_BUCKET,
                    XMaterial.COD_BUCKET,
                    XMaterial.SALMON_BUCKET,
                    XMaterial.PUFFERFISH_BUCKET,
                    XMaterial.TROPICAL_FISH_BUCKET,
                    XMaterial.AXOLOTL_BUCKET,
                    XMaterial.TADPOLE_BUCKET,
                    XMaterial.POWDER_SNOW_BUCKET)
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> AIR = Stream.of(
                    XMaterial.AIR,
                    XMaterial.CAVE_AIR,
                    XMaterial.VOID_AIR)
            .filter(XMaterial::isSupported)
            .map(XMaterial::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static boolean isElytra(@Nullable ItemStack itemStack) {
        return itemStack != null && itemStack.getType() == XMaterial.ELYTRA.get();
    }

    @SuppressWarnings("deprecation")
    public static boolean isPlayerHead(BlockState blockState) {
        if (!PLAYER_HEADS.contains(blockState.getType()))
            return false;
        if (PlatformUtil.getMinecraftVersion() > 12)
            return true;
        Skull skull = (Skull) blockState;
        return skull.getSkullType() == SkullType.PLAYER || skull.hasOwner();
    }

    @SuppressWarnings("deprecation")
    public static boolean isPlayerHead(ItemStack itemStack) {
        if (!PLAYER_HEADS.contains(itemStack.getType()))
            return false;
        if (PlatformUtil.getMinecraftVersion() > 12)
            return true; // Player heads have their own Material enum post 1.12.2
        if (!itemStack.hasItemMeta())
            return false;
        if (((SkullMeta) itemStack.getItemMeta()).hasOwner())
            return true;
        if (itemStack.getItemMeta() instanceof BlockStateMeta) {
            BlockStateMeta blockStateMeta = (BlockStateMeta) itemStack.getItemMeta();
            if (blockStateMeta.hasBlockState() && blockStateMeta.getBlockState() instanceof Skull) {
                return ((Skull) blockStateMeta.getBlockState()).getSkullType() == SkullType.PLAYER;
            }
        }
        return false;
    }
}