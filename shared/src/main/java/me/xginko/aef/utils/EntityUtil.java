package me.xginko.aef.utils;

import com.cryptomorin.xseries.XEntityType;
import com.cryptomorin.xseries.XMaterial;
import org.bukkit.entity.ChestedHorse;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.ItemFrame;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Projectile;
import org.bukkit.entity.Vehicle;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.MapMeta;
import org.bukkit.map.MapView;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class EntityUtil {

    public static final boolean MAP_SET_TRACKING_POS_AVAILABLE, IS_SWIMMING_AVAILABLE, IS_SET_PERSISTENT_AVAILABLE;

    static {
        MAP_SET_TRACKING_POS_AVAILABLE
                =   Crafty.hasClass("org.bukkit.map.MapView")
                &&  Crafty.hasMethod(MapView.class, "setTrackingPosition", boolean.class);
        IS_SWIMMING_AVAILABLE
                =   Crafty.hasMethod(LivingEntity.class, "isSwimming", boolean.class);
        IS_SET_PERSISTENT_AVAILABLE
                =   Crafty.hasMethod(Entity.class, "setPersistent", boolean.class);
    }

    public static void setPersistent(Entity entity, boolean persistent) {
        if (IS_SET_PERSISTENT_AVAILABLE) {
            entity.setPersistent(persistent);
        }
    }

    /**
     * Disables that a position cursor will be shown when the map is near its center.
     *
     * @param itemFrame the {@link ItemFrame} entity to disable the tracking status of
     */
    public static void disableMapPositionCursor(@NotNull ItemFrame itemFrame) {
        if (!MAP_SET_TRACKING_POS_AVAILABLE) return;

        ItemStack itemInsideFrame = itemFrame.getItem();
        if (itemInsideFrame == null) return; // Shouldn't be null but just in case
        if (itemInsideFrame.getType() != XMaterial.MAP.parseMaterial()
                && itemInsideFrame.getType() != XMaterial.FILLED_MAP.parseMaterial()) return;
        if (!itemInsideFrame.hasItemMeta()) return;

        MapMeta mapMeta = (MapMeta) itemInsideFrame.getItemMeta();
        if (!mapMeta.hasMapView()) return;
        MapView mapView = mapMeta.getMapView();
        if (mapView == null) return;

        mapView.setTrackingPosition(false);

        itemInsideFrame.setItemMeta(mapMeta);
        itemFrame.setItem(itemInsideFrame);
    }

    /**
     * Checks to see if an entity is swimming.
     *
     * @return True if this entity is swimming.
     */
    public static boolean isSwimming(LivingEntity livingEntity) {
        return IS_SWIMMING_AVAILABLE && livingEntity.isSwimming();
    }

    public static final Set<EntityType> MINECARTS = Arrays.stream(XEntityType.values())
            .filter(xEntityType -> xEntityType.name().toUpperCase().contains("MINECART"))
            .filter(XEntityType::isSupported)
            .map(XEntityType::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(EntityType.class)));

    public static final Set<EntityType> ITEM_FRAMES = Arrays.stream(XEntityType.values())
            .filter(xEntityType -> xEntityType.name().toUpperCase().contains("ITEM_FRAME"))
            .filter(XEntityType::isSupported)
            .map(XEntityType::get)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(EntityType.class)));

    private static final Map<EntityType, Boolean> IS_INVHOLDER_CACHE = new EnumMap<>(EntityType.class);
    public static boolean isInventoryHolder(Entity entity) {
        if (entity == null) return false;
        return IS_INVHOLDER_CACHE.computeIfAbsent(entity.getType(), entityType -> entity instanceof InventoryHolder);
    }

    private static final Map<EntityType, Boolean> IS_CHESTABLE_CACHE = new EnumMap<>(EntityType.class);
    public static boolean isChestableHorse(Entity entity) {
        if (entity == null) return false;
        return IS_CHESTABLE_CACHE.computeIfAbsent(entity.getType(), entityType -> entity instanceof ChestedHorse);
    }

    private static final Map<EntityType, Boolean> IS_LIVING_CACHE = new EnumMap<>(EntityType.class);
    public static boolean isLivingEntity(Entity entity) {
        if (entity == null) return false;
        return IS_LIVING_CACHE.computeIfAbsent(entity.getType(), entityType -> entity instanceof LivingEntity);
    }

    private static final Map<EntityType, Boolean> IS_VEHICLE_CACHE = new EnumMap<>(EntityType.class);
    public static boolean isVehicle(Entity entity) {
        if (entity == null) return false;
        return IS_VEHICLE_CACHE.computeIfAbsent(entity.getType(), entityType -> entity instanceof Vehicle);
    }

    private static final Map<EntityType, Boolean> IS_PROJECTILE_CACHE = new EnumMap<>(EntityType.class);
    public static boolean isProjectile(Entity entity) {
        if (entity == null) return false;
        return IS_PROJECTILE_CACHE.computeIfAbsent(entity.getType(), entityType -> entity instanceof Projectile);
    }
}
