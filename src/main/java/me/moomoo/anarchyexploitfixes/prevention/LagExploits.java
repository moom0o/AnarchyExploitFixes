package me.moomoo.anarchyexploitfixes.prevention;

import lombok.RequiredArgsConstructor;
import me.moomoo.anarchyexploitfixes.Main;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPhysicsEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityPortalEvent;
import org.bukkit.event.entity.ExpBottleEvent;
import org.bukkit.event.entity.ProjectileLaunchEvent;
import org.bukkit.event.vehicle.VehicleCreateEvent;

import java.awt.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

@RequiredArgsConstructor
public class LagExploits implements Listener {
    private final Main plugin;
    private final HashMap<String, Integer> throwCoolDown = new HashMap<>();
    private final Set<Location> throwCoolDownLocations = new HashSet<>();

    @EventHandler
    private void onEntityChange(BlockPhysicsEvent evt) {
        double tpsDouble = Bukkit.getServer().getTPS()[0];

        if (evt.getChangedType().hasGravity()) {
            FileConfiguration config = plugin.getConfig();

            if (tpsDouble < config.getDouble("FallingBlocks")) {
                evt.setCancelled(true);
            } else {
                if (config.getBoolean("LimitFallingBlocks")) {
                    if (count(evt.getBlock().getChunk().getEntities(), EntityType.FALLING_BLOCK) > config.getInt("FallingBlockLimit")) {
                        evt.setCancelled(true);
                    }
                }
            }
        }
    }

    @EventHandler
    private void onCreate(VehicleCreateEvent evt) {
        FileConfiguration config = plugin.getConfig();

        if (config.getBoolean("PreventMinecartLag")) {
            if (plugin.countVehicles(evt.getVehicle().getChunk().getEntities()) > config.getInt("MaxVehiclesInChunk")) {
                evt.setCancelled(true);
            }
        }
    }

    @EventHandler
    private void onPlace(BlockPlaceEvent evt) {
        if (evt.getBlockPlaced().getType().hasGravity()) {
            FileConfiguration config = plugin.getConfig();

            if (config.getBoolean("LimitFallingBlocks")) {
                if (count(evt.getBlock().getChunk().getEntities(), EntityType.FALLING_BLOCK) > config.getInt("FallingBlockLimit")) {
                    evt.setCancelled(true);
                }
            }
        }
    }

    @EventHandler
    private void onExpBottle(ExpBottleEvent evt) {
        FileConfiguration config = plugin.getConfig();
        if (config.getBoolean("LimitExpBottles")) {
            if (count(evt.getEntity().getChunk().getEntities(), EntityType.THROWN_EXP_BOTTLE) > config.getInt("ExpBottleLimit")) {
                removeExp(evt.getEntity().getChunk().getEntities());
            }
        }
    }

    @EventHandler
    private void onPortal(EntityPortalEvent evt) {
        FileConfiguration config = plugin.getConfig();

        if (config.getBoolean("PreventProjectilesFromGoingThroughPortals")) {
            if (evt.getEntityType().isSpawnable() && !evt.getEntityType().isAlive()) {
                evt.setCancelled(true);
            }
        }
    }

    @EventHandler
    private void onThrow(ProjectileLaunchEvent evt) {
        FileConfiguration config = plugin.getConfig();

        if (config.getBoolean("PreventSnowBallExploit")) {
            boolean found = false;
            for (Player p : Bukkit.getOnlinePlayers()) {
                Point p1 = new Point(evt.getEntity().getLocation().getBlockX(), evt.getEntity().getLocation().getBlockZ());
                Point p2 = new Point(p.getLocation().getBlockX(), p.getLocation().getBlockZ());
                if (p1.distance(p2) <= 1) {
                    found = true;
                    if (throwCoolDown.get(p.getName()) != null && throwCoolDown.get(p.getName()) > config.getInt("ProjectilesMaxPerTime")) {
                        if (evt.getEntity().getType() != EntityType.THROWN_EXP_BOTTLE) {
                            evt.setCancelled(true);
                        }
                    } else {
                        throwCoolDown.merge(p.getName(), 1, Integer::sum);
                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> throwCoolDown.put(p.getName(), throwCoolDown.get(p.getName()) - 1), config.getInt("ProjectileTimeTicks"));
                    }
                }
            }
            if (!found) {
                boolean done = false;
                for (Location l : throwCoolDownLocations) {
                    Point p1 = new Point(evt.getEntity().getLocation().getBlockX(), evt.getEntity().getLocation().getBlockZ());
                    Point p2 = new Point(l.getBlockX(), l.getBlockZ());
                    // We check if the entity is anywhere near our last
                    if (p1.distance(p2) <= 100) {
                        done = true;
                        evt.setCancelled(true);
                    }
                }
                if (!done) {
                    Location location = evt.getEntity().getLocation();
                    throwCoolDownLocations.add(location);
                    Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> throwCoolDownLocations.remove(location), 20L);
                }
            }
        }
    }

    private Integer count(Entity[] e, EntityType type) {
        Integer count = 0;
        for (Entity entity : e) {
            if (entity.getType().equals(type)) {
                count++;
            }
        }
        return count;
    }

    private void removeExp(Entity[] e) {
        for (Entity entity : e) {
            if (entity.getType().equals(EntityType.THROWN_EXP_BOTTLE)) {
                entity.remove();
            }
        }
    }
}
