package me.moomoo.anarchyexploitfixes.patches;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.BlockPosition;
import com.comphenix.protocol.wrappers.EnumWrappers;
import io.papermc.lib.PaperLib;
import me.moomoo.anarchyexploitfixes.Main;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.*;

public class ProtocolLib {
    public static void protocolLibWrapper(Main plugin) {
        final Set<String> crafting = new HashSet<>();
        final Map<UUID, Integer> levels = new HashMap<>();
        final Map<UUID, Integer> boatLevels = new HashMap<>();
        ProtocolManager protocolManager = ProtocolLibrary.getProtocolManager();
        if (plugin.getConfig().getBoolean("PreventCraftingRecipeLagExploit")) {
            protocolManager.addPacketListener(
                    new PacketAdapter(plugin, ListenerPriority.NORMAL, PacketType.Play.Client.AUTO_RECIPE) {
                        @Override
                        public void onPacketReceiving(PacketEvent event) {
                            if (event.isPlayerTemporary()) {
                                return;
                            }

                            if (crafting.contains(event.getPlayer().getName())) {
                                event.setCancelled(true);
                            } else {
                                crafting.add(event.getPlayer().getName());
                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> crafting.remove(event.getPlayer().getName()), plugin.getConfig().getInt("CraftingRecipeDelay"));
                            }
                        }
                    });
        }

        if (plugin.getConfig().getBoolean("PreventPacketFly")) {
            protocolManager.addPacketListener(
                    new PacketAdapter(plugin, ListenerPriority.HIGHEST, PacketType.Play.Client.TELEPORT_ACCEPT) {
                        @Override
                        public void onPacketReceiving(PacketEvent event) {
                            if (event.isPlayerTemporary()) {
                                return;
                            }

                            Player e = event.getPlayer();
                            Location l = e.getLocation();
                            int relX = l.getBlockX() & 0xF; // keep the 4 least significant bits, range 0-15
                            int relY = l.getBlockY();
                            int relZ = l.getBlockZ() & 0xF;

                            Chunk chunk = PaperLib.getChunkAtAsync(l, false).join();
                            if (chunk != null
                                    && (relY <= 0 || chunk.getBlock(relX, relY - 1, relZ).getType() == Material.AIR)
                                    && !e.isGliding()
                                    && !e.isInsideVehicle()) {
                                Integer level = levels.get(e.getUniqueId());
                                if (level != null) {
                                    if (level > plugin.getConfig().getInt("MaxTeleportPacketsPer10Seconds")) {
                                        event.setCancelled(true);
                                        if (plugin.getConfig().getBoolean("LogPacketFlyEvents")) {
                                            plugin.getLogger().warning(e.getName() + " prevented from packetflying");
                                        }
                                    } else {
                                        levels.merge(e.getUniqueId(), 1, Integer::sum);
                                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e.getUniqueId(), levels.get(e.getUniqueId()) - 1), 200L);
                                    }
                                } else {
                                    levels.put(e.getUniqueId(), 1);
                                    Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e.getUniqueId(), levels.get(e.getUniqueId()) - 1), 200L);
                                }
                            }
                        }
                    });
        }

        if (plugin.getConfig().getBoolean("BoatflyPatch")) {
            protocolManager.addPacketListener(
                    new PacketAdapter(plugin, ListenerPriority.HIGHEST, PacketType.Play.Client.USE_ENTITY) {
                        @Override
                        public void onPacketReceiving(PacketEvent event) {
                            if (event.isPlayerTemporary()) {
                                return;
                            }

                            Player e = event.getPlayer();
                            if (e.isInsideVehicle() && e.getVehicle().getType() == EntityType.BOAT) {
                                if (boatLevels.get(e.getUniqueId()) != null) {
                                    if (boatLevels.get(e.getUniqueId()) > plugin.getConfig().getInt("MaxEntityPacketsPer10Seconds")) {
                                        new BukkitRunnable() {
                                            public void run() {
                                                e.getVehicle().remove();
                                            }
                                        }.runTask(plugin);
                                        if (plugin.getConfig().getBoolean("LogBoatFlyEvents")) {
                                            plugin.getLogger().warning(e.getName() + " prevented from boatflying");
                                        }
                                    } else {
                                        boatLevels.merge(e.getUniqueId(), 1, Integer::sum);
                                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e.getUniqueId(), boatLevels.get(e.getUniqueId()) - 1), 200L);
                                    }
                                } else {
                                    boatLevels.put(e.getUniqueId(), 1);
                                    Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e.getUniqueId(), boatLevels.get(e.getUniqueId()) - 1), 200L);
                                }

                            }
                        }
                    });
        }

        if (plugin.getConfig().getBoolean("PreventNoComCoordinateExploit")) {
            protocolManager.addPacketListener(
                    new PacketAdapter(plugin, ListenerPriority.NORMAL, PacketType.Play.Client.BLOCK_DIG) {
                        @Override
                        public void onPacketReceiving(PacketEvent event) {
                            if (event.isPlayerTemporary()) {
                                return;
                            }

                            final EnumWrappers.PlayerDigType t = event.getPacket().getPlayerDigTypes().read(0);
                            if (t.equals(EnumWrappers.PlayerDigType.START_DESTROY_BLOCK) || t.equals(EnumWrappers.PlayerDigType.ABORT_DESTROY_BLOCK) || t.equals(EnumWrappers.PlayerDigType.STOP_DESTROY_BLOCK)) {
                                final BlockPosition packetLocation = event.getPacket().getBlockPositionModifier().read(0);
                                if (event.getPlayer().getLocation().distance(packetLocation.toLocation(event.getPlayer().getWorld())) > plugin.getConfig().getInt("NoComMaxDistance")) {
                                    event.setCancelled(true);
                                }
                            }
                        }
                    });
            // Bypass - Causing errors on 1.17.1. - Please let me know if there is a way to fix this. https://paste.ee/p/BdWAH Shouldn't be much of an issue as I believe nocom is fixed in newer versions of Paper.
            if (plugin.getConfig().getBoolean("OverideConfigChanges") || Bukkit.getVersion().contains("1.12")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(plugin, ListenerPriority.NORMAL, PacketType.Play.Client.USE_ITEM) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                if (event.isPlayerTemporary()) {
                                    return;
                                }

                                final BlockPosition packetLocation = event.getPacket().getBlockPositionModifier().read(0);
                                if (event.getPlayer().getLocation().distance(packetLocation.toLocation(event.getPlayer().getWorld())) > plugin.getConfig().getInt("NoComMaxDistance")) {
                                    event.setCancelled(true);
                                }
                            }
                        });
            }
        }
    }
}
