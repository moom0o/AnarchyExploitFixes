package me.moomoo.anarchyexploitfixes.misc;

import lombok.RequiredArgsConstructor;
import me.moomoo.anarchyexploitfixes.Main;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.World;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;

import java.awt.*;

@RequiredArgsConstructor
public class CommandPreProcess implements Listener {
    private final Main plugin;

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onCommandPreprocess(PlayerCommandPreprocessEvent evt) {
        FileConfiguration config = plugin.getConfig();

        if (evt.getMessage().equalsIgnoreCase("/aef")) {
            evt.getPlayer().sendMessage(ChatColor.GOLD + "This server is running AnarchyExploitFixes v" + plugin.getDescription().getVersion());
            evt.setCancelled(true);
        }

        if (config.getBoolean("FixChatcoIgnoreBug") && evt.getMessage().equalsIgnoreCase("/ignore")) {
            if (evt.getPlayer().getLocale().startsWith("es")) {
                evt.getPlayer().sendMessage(ChatColor.RED + "No agregaste un nombre de jugador...");
            } else {
                evt.getPlayer().sendMessage(ChatColor.RED + "You didn't add a player name...");
            }
            evt.setCancelled(true);
        }

        if (config.getBoolean("UseSparkhealth") && evt.getMessage().equalsIgnoreCase("/tps")) {
            evt.getPlayer().performCommand("spark health");
            evt.setCancelled(true);

            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> {
                if (evt.getPlayer().getLocale().startsWith("es")) {
                    evt.getPlayer().sendMessage(ChatColor.GRAY + "Este no es el tamaño mundial, para el tipo /stats de tamaño mundial");
                } else {
                    evt.getPlayer().sendMessage(ChatColor.GRAY + "This is not the world size, for world size type /stats");
                }
            }, 10L);
        }

        if (config.getBoolean("nickresetonly") && evt.getMessage().toLowerCase().startsWith("/nick")) {
            if (!evt.getMessage().equalsIgnoreCase("/nick off")) {
                if (evt.getPlayer().getLocale().startsWith("es")) {
                    evt.getPlayer().sendMessage(ChatColor.BLUE + "No puedes cambiar tu nick pero puedes restablecerlo escribiendo /nick off si tienes un nick viejo!");
                } else {
                    evt.getPlayer().sendMessage(ChatColor.BLUE + "You can't change your nick but you may reset it by typing /nick off if you have a legacy nick!");
                }
                evt.setCancelled(true);
            }
        }

        if (evt.getMessage().toLowerCase().startsWith("/tpa ") || evt.getMessage().equalsIgnoreCase("/tpa") || evt.getMessage().toLowerCase().startsWith("/tpahere") || evt.getMessage().toLowerCase().startsWith("/call") || evt.getMessage().toLowerCase().startsWith("/ecall") || evt.getMessage().toLowerCase().startsWith("/etpa") || evt.getMessage().toLowerCase().startsWith("/tpask") || evt.getMessage().toLowerCase().startsWith("/etpask")) {
            if (config.getBoolean("5000blocksawaytoteleport")) {
                if (!evt.getPlayer().getWorld().getEnvironment().equals(World.Environment.THE_END)) {
                    Point p1 = new Point(evt.getPlayer().getLocation().getBlockX(), evt.getPlayer().getLocation().getBlockZ());
                    Point p2 = new Point(0, 0);
                    if (p1.distance(p2) < 5000) {
                        if (evt.getPlayer().getLocale().startsWith("es")) {
                            evt.getPlayer().sendMessage(ChatColor.BLUE + "Necesitas ser 5000 cuadras de spawn para teletransportarse!");
                        } else {
                            evt.getPlayer().sendMessage(ChatColor.BLUE + "You need to be 5000 blocks away from spawn to teleport!");
                        }
                        evt.setCancelled(true);
                    }
                }
            }
        }

        String msg = evt.getMessage().toLowerCase();
        if (config.getBoolean("AllowOPStobypass")) {
            if (config.getBoolean("CommandWhitelist") && !config.getList("CommandsWhitelisted").contains(msg.split(" ")[0])) {
                if (!evt.getPlayer().isOp()) {
                    if (evt.getPlayer().getLocale().startsWith("es")) {
                        evt.getPlayer().sendMessage(ChatColor.DARK_RED + "Mal comando. Tipo /help para todos los comandos.");
                    } else {
                        evt.getPlayer().sendMessage(ChatColor.DARK_RED + "Bad command. Type /help for all commands.");
                    }
                    evt.setCancelled(true);
                }
            }
        } else {
            if (config.getBoolean("CommandWhitelist") && !config.getList("CommandsWhitelisted").contains(msg.split(" ")[0])) {
                if (evt.getPlayer().getLocale().startsWith("es")) {
                    evt.getPlayer().sendMessage(ChatColor.DARK_RED + "Mal comando. Tipo /help para todos los comandos.");
                } else {
                    evt.getPlayer().sendMessage(ChatColor.DARK_RED + "Bad command. Type /help for all commands.");
                }

                evt.setCancelled(true);
            }
        }

        if (config.getBoolean("MakeSpecificCommandsHurtYou") && config.getList("HurtCommands").contains(msg.split(" ")[0])) {
            evt.getPlayer().damage(10L);
            evt.setCancelled(true);
        }
    }
}
