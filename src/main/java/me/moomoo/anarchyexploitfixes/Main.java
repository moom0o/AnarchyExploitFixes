package me.moomoo.anarchyexploitfixes;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import me.moomoo.anarchyexploitfixes.misc.*;
import me.moomoo.anarchyexploitfixes.patches.*;
import me.moomoo.anarchyexploitfixes.prevention.*;
import org.bstats.bukkit.Metrics;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

public class Main extends JavaPlugin implements Listener {
    public final Map<Player, Integer> newChunks = new HashMap<>();
    public final Map<Player, Integer> oldChunks = new HashMap<>();

    private static final int[] oldTotal = {0};
    private static final int[] newTotal = {0};

    public Set<String> crafting = new HashSet<>();

    public Map<Player, Integer> levels = new HashMap<>();
    public Map<Player, Integer> boatLevels = new HashMap<>();
    ProtocolManager protocolManager;
    private Logger log;

    public static int[] getOldTotal() {
        return oldTotal;
    }

    public static int[] getNewTotal() {
        return newTotal;
    }

    @Override
    public void onEnable() {
        log = getLogger();
        PluginManager pm = getServer().getPluginManager();
        FileConfiguration config = getConfig();

        log.info(ChatColor.AQUA + "Loading config");
        saveDefaultConfig();

        log.info(ChatColor.AQUA + "Registering events");
        // please make a pull request if there is a better way to do this
        pm.registerEvents(new DupeFixes(this), this);
        pm.registerEvents(new DisableWithers(this), this);
        pm.registerEvents(new Elytra(this), this);
        pm.registerEvents(new EndPortalPatch(this), this);
        pm.registerEvents(new Bedrock(this), this);
        pm.registerEvents(new Boats(this), this);
        pm.registerEvents(new Chat(this), this);
        pm.registerEvents(new ChunkBan(this), this);
        pm.registerEvents(new CommandPreProcess(this), this);
        pm.registerEvents(new CrashExploits(this), this);
        pm.registerEvents(new Illegals(this), this);
        pm.registerEvents(new JoinMessages(this), this);
        pm.registerEvents(new Kicks(this), this);
        pm.registerEvents(new LagExploits(this), this);
        pm.registerEvents(new MyServer(this), this);
        pm.registerEvents(new NetherRoof(this), this);
        pm.registerEvents(new Redstone(this), this);
        pm.registerEvents(new NetherPortals(this), this);
        if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
            // I would put this in a seperate class if I could however I cba to deal with the annoying ass static errors.
            getLogger().info("Detected ProtocolLib!");
            protocolManager = ProtocolLibrary.getProtocolManager();
            if (config.getBoolean("PreventCraftingRecipeLagExploit")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.NORMAL, PacketType.Play.Client.AUTO_RECIPE) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                if (event.getPacketType() == PacketType.Play.Client.AUTO_RECIPE) {
                                    if (crafting.contains(event.getPlayer().getName())) {
                                        event.setCancelled(true);

                                    } else {
                                        crafting.add(event.getPlayer().getName());
                                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> crafting.remove(event.getPlayer().getName()), 1L);
                                    }
                                }
                            }
                        });
            }
            if (config.getBoolean("PreventPacketFly")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.HIGHEST, PacketType.Play.Client.TELEPORT_ACCEPT) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                Player e = event.getPlayer();
                                Location l = event.getPlayer().getLocation();
                                if (event.getPlayer().getWorld().getBlockAt(l.getBlockX(), l.getBlockY() - 1, l.getBlockZ()).getType() == Material.AIR && !e.isGliding() && !e.isInsideVehicle()) {
                                    if (event.getPacketType() == PacketType.Play.Client.TELEPORT_ACCEPT) {
                                        if (levels.get(e) != null) {
                                            if (levels.get(e) > getConfig().getInt("MaxTeleportPacketsPer10Seconds")) {
                                                event.setCancelled(true);
                                                if (getConfig().getBoolean("LogPacketFlyEvents")) {
                                                    getLogger().warning(e.getName() + " prevented from packetflying");
                                                }
                                            } else {
                                                levels.merge(e, 1, Integer::sum);
                                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e, levels.get(e) - 1), 200L);
                                            }
                                        } else {
                                            levels.put(e, 1);
                                            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e, levels.get(e) - 1), 200L);
                                        }
                                    }
                                }
                            }
                        });
            }
            if (config.getBoolean("BoatflyPatch")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.HIGHEST, PacketType.Play.Client.USE_ENTITY) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                Player e = event.getPlayer();
                                if (e.isInsideVehicle() && e.getVehicle().getType() == EntityType.BOAT) {
                                    if (event.getPacketType() == PacketType.Play.Client.USE_ENTITY) {
                                        if (boatLevels.get(e) != null) {
                                            if (boatLevels.get(e) > getConfig().getInt("MaxEntityPacketsPer10Seconds")) {
                                                e.getVehicle().remove();
                                                if (getConfig().getBoolean("LogBoatFlyEvents")) {
                                                    getLogger().warning(e.getName() + " prevented from boatflying");
                                                }
                                            } else {
                                                boatLevels.merge(e, 1, Integer::sum);
                                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e, boatLevels.get(e) - 1), 200L);
                                            }
                                        } else {
                                            boatLevels.put(e, 1);
                                            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e, boatLevels.get(e) - 1), 200L);
                                        }
                                    }
                                }
                            }
                        });
            }
        } else {
            getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
        }
        log.info("Registering events finished");
        log.info("Registering commands");
        getCommand("aef").setExecutor(new Commands(this));
        if (config.getBoolean("StrictIllegalPrevention")) {
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> e.getInventory().forEach(bb -> {
                if (bb != null) {
                    if (config.getBoolean("OnlyRevertStacksForCertainItems")) {
                        for (String s : config.getStringList("RevertStackedItemsList")) {
                            if (bb.getType().name().equals(s)) {
                                if (bb.getAmount() > bb.getMaxStackSize()) {
                                    bb.setAmount(bb.getMaxStackSize());
                                }
                            }
                        }
                    } else {
                        if (bb.getAmount() > bb.getMaxStackSize()) {
                            bb.setAmount(bb.getMaxStackSize());
                        }
                    }
                }
            }))), 0L, 20L);
        }

        Bukkit.getScheduler().runTaskTimer(this, () -> {
            newTotal[0] = 0;
            oldTotal[0] = 0;
            Bukkit.getOnlinePlayers().forEach(player -> {
                if (newChunks.get(player) != null) {
                    newTotal[0] = newTotal[0] + newChunks.get(player);
                }
            });
            Bukkit.getOnlinePlayers().forEach(player -> {
                if (oldChunks.get(player) != null) {
                    oldTotal[0] = oldTotal[0] + oldChunks.get(player);
                }
            });
        }, 0L, 20L);

        log.info(ChatColor.AQUA + "Looking for hooks");
        if (Bukkit.getPluginManager().getPlugin("PlaceholderAPI") != null)
            new Expansions(this).register();

        log.info(ChatColor.AQUA + "Loading metrics");
        new Metrics(this, 8700);

        log.info(ChatColor.AQUA + "[ENABLED] AnarchyExploitFixes - Made by moomoo");
    }

    @Override
    public void onDisable() {
        log.info("[DISABLED] AnarchyExploitFixes - Made by moomoo");
    }

    public Integer checkChunk(Material material, Chunk c) {
        int count = 0;
        int cx = c.getX() << 4;
        int cz = c.getZ() << 4;

        for (int x = cx; x < cx + 16; x++) {
            for (int z = cz; z < cz + 16; z++) {
                for (int y = 0; y < 256; y++) {
                    if (c.getBlock(x, y, z).getType() == material) {
                        count++;
                    }
                }
            }
        }

        return count;
    }

}
