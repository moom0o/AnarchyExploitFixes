package me.xginko.aef.utils;

import me.xginko.aef.AnarchyExploitFixes;
import org.apache.commons.math3.util.FastMath;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.util.NumberConversions;

public class LocationUtil {

    public static String toString(Location location) {
        return "[" + location.getWorld().getName() + "] x=" + location.getBlockX() + ", y=" + location.getBlockY() + ", z=" + location.getBlockZ();
    }

    public static boolean isNetherCeiling(Location location) {
        return location.getWorld().getEnvironment() == World.Environment.NETHER
                && location.getY() > AnarchyExploitFixes.config().nether_ceiling_max_y;
    }

    public static double getSquaredDistance2DTo00(Location location) {
        return NumberConversions.square(location.getX()) + NumberConversions.square(location.getZ());
    }

    public static double getDistance2DTo00(Location location) {
        return FastMath.hypot(location.getX(), location.getZ());
    }

    public static double getRelSquaredDistance2D(Location from, Location to) {
        double toX = to.getX();
        double toZ = to.getZ();
        double fromX = from.getX();
        double fromZ = from.getZ();

        final World.Environment toEnv = to.getWorld().getEnvironment();
        final World.Environment fromEnv = from.getWorld().getEnvironment();
        if (toEnv != fromEnv) {
            if (fromEnv == World.Environment.NETHER) {
                fromX *= 8;
                fromZ *= 8;
            }
            if (toEnv == World.Environment.NETHER) {
                toX *= 8;
                toZ *= 8;
            }
        }

        return  NumberConversions.square(toX - fromX) +
                NumberConversions.square(toZ - fromZ);
    }

    public static double getRelDistance2D(Location from, Location to) {
        double toX = to.getX();
        double toZ = to.getZ();
        double fromX = from.getX();
        double fromZ = from.getZ();

        final World.Environment toEnv = to.getWorld().getEnvironment();
        final World.Environment fromEnv = from.getWorld().getEnvironment();
        if (toEnv != fromEnv) {
            if (fromEnv == World.Environment.NETHER) {
                fromX *= 8;
                fromZ *= 8;
            }
            if (toEnv == World.Environment.NETHER) {
                toX *= 8;
                toZ *= 8;
            }
        }

        return FastMath.hypot(toX - fromX, toZ - fromZ);
    }

    public static double getRelSquaredDistance3D(Location from, Location to) {
        double toX = to.getX();
        double toZ = to.getZ();
        double fromX = from.getX();
        double fromZ = from.getZ();

        final World.Environment toEnv = to.getWorld().getEnvironment();
        final World.Environment fromEnv = from.getWorld().getEnvironment();
        if (toEnv != fromEnv) {
            if (fromEnv == World.Environment.NETHER) {
                fromX *= 8;
                fromZ *= 8;
            }
            if (toEnv == World.Environment.NETHER) {
                toX *= 8;
                toZ *= 8;
            }
        }

        return  NumberConversions.square(toX - fromX) +
                NumberConversions.square(from.getY() - to.getY()) +
                NumberConversions.square(toZ - fromZ);
    }

    public static double getRelDistance3D(Location from, Location to) {
        double toX = to.getX();
        double toZ = to.getZ();
        double fromX = from.getX();
        double fromZ = from.getZ();

        final World.Environment toEnv = to.getWorld().getEnvironment();
        final World.Environment fromEnv = from.getWorld().getEnvironment();
        if (toEnv != fromEnv) {
            if (fromEnv == World.Environment.NETHER) {
                fromX *= 8;
                fromZ *= 8;
            }
            if (toEnv == World.Environment.NETHER) {
                toX *= 8;
                toZ *= 8;
            }
        }

        return getDistance3D(fromX - toX, from.getY() - to.getY(), fromZ - toZ);
    }

    /**
     * Avoids intermediate overflow or underflow.
     *
     * <ul>
     * <li> If any argument is infinite, then the result is positive infinity.</li>
     * <li> else, if any argument is NaN then the result is NaN.</li>
     * </ul>
     *
     * @param deltaX the x-axis delta
     * @param deltaY the y-axis delta
     * @param deltaZ the z-axis delta
     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>&nbsp;+<i>z</i><sup>2</sup>)<br/>
     */
    public static double getDistance3D(final double deltaX, final double deltaY, final double deltaZ) {
        if (Double.isInfinite(deltaX) || Double.isInfinite(deltaY) || Double.isInfinite(deltaZ)) {
            return Double.POSITIVE_INFINITY;
        } else if (Double.isNaN(deltaX) || Double.isNaN(deltaY) || Double.isNaN(deltaZ)) {
            return Double.NaN;
        } else {
            final int expX = FastMath.getExponent(deltaX);
            final int expY = FastMath.getExponent(deltaY);
            final int expZ = FastMath.getExponent(deltaZ);

            if (expX > expY + 27 && expX > expZ + 27) {
                // x is neglectible with respect to y and z
                return FastMath.abs(deltaY) + FastMath.abs(deltaZ);
            } else if (expY > expX + 27 && expY > expZ + 27) {
                // y is neglectible with respect to x and z
                return FastMath.abs(deltaX) + FastMath.abs(deltaZ);
            } else if (expZ > expX + 27 && expZ > expY + 27) {
                // z is neglectible with respect to x and y
                return FastMath.abs(deltaX) + FastMath.abs(deltaY);
            } else {
                final int middleExp = (expX + expY + expZ) / 3;

                final double scaledX = FastMath.scalb(deltaX, -middleExp);
                final double scaledY = FastMath.scalb(deltaY, -middleExp);
                final double scaledZ = FastMath.scalb(deltaZ, -middleExp);

                final double scaledH = Math.sqrt(scaledX * scaledX + scaledY * scaledY + scaledZ * scaledZ);

                return FastMath.scalb(scaledH, middleExp);
            }
        }
    }
}
