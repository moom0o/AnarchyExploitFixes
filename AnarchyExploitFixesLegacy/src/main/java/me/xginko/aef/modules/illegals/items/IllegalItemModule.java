package me.xginko.aef.modules.illegals.items;

import com.cryptomorin.xseries.XMaterial;
import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.ChunkUtil;
import me.xginko.aef.utils.EntityUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.WorldUtil;
import me.xginko.aef.utils.enums.IllegalHandling;
import me.xginko.aef.utils.enums.ItemLegality;
import me.xginko.aef.utils.models.ExpiringSet;
import me.xginko.aef.utils.permissions.AEFPermission;
import org.bukkit.Chunk;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockDispenseEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryDragEvent;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.event.player.PlayerAttemptPickupItemEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerItemConsumeEvent;
import org.bukkit.event.player.PlayerItemHeldEvent;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.checker.nullness.qual.PolyNull;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

public abstract class IllegalItemModule extends AEFModule implements Listener {

    protected final AEFPermission bypassPermission;
    protected final IllegalHandling illegalHandling;
    protected final boolean guiPluginsSupported;

    protected final Set<Listener> optionalListeners;
    protected final Cache<Class<? extends Event>, ExpiringSet<Object>> listenerCooldowns;
    protected final Function<Class<? extends Event>, @PolyNull ExpiringSet<Object>> createIfAbsent;

    public IllegalItemModule(String configPath, AEFPermission bypassPermission) {
        this(configPath, false, bypassPermission, null);
    }

    public IllegalItemModule(String configPath, boolean defEnabled, AEFPermission bypassPermission, String comment) {
        super(configPath, defEnabled, comment);
        this.bypassPermission = bypassPermission;
        this.optionalListeners = new HashSet<>(6);

        String configuredHandling = config.getString(configPath + ".handling", IllegalHandling.PREVENT_USE_ONLY.name(),
                "Available options:\n" + Arrays.stream(IllegalHandling.values())
                        .map(option -> option.name() + " - " + option.description())
                        .collect(Collectors.joining("\n")));
        IllegalHandling handling;
        try {
            handling = IllegalHandling.valueOf(configuredHandling);
        } catch (IllegalArgumentException e) {
            handling = IllegalHandling.PREVENT_USE_ONLY;
            warn("Handling option '" + configuredHandling + "' not recognized. Defaulting to " + handling.name());
        }
        this.illegalHandling = handling;

        this.guiPluginsSupported = config.getBoolean(configPath + ".gui-plugins-supported", false,
                "Enable this if you have problems with the plugin removing items from chest guis.");
        if (this.illegalHandling == IllegalHandling.STRICT) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
                private void onInventoryOpen(InventoryOpenEvent event) {
                    if (AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) return;
                    // Check if the inventory is connected to a location in the game. If it is not,
                    // it was very likely created by a plugin
                    if (!guiPluginsSupported || event.getInventory().getLocation() != null) {
                        for (ItemStack invItem : event.getInventory()) {
                            handleItem(invItem, legalityOf(invItem));
                        }
                    }
                }
            });
        }

        if (config.getBoolean(configPath + ".prevent-hopper32k-mechanic", false,
                "Prevents Hopper32k mechanic of placing a shulker containing illegals on top\n" +
                "of a hopper, then using the illegal out of the hopper's inventory.\n" +
                "No longer hooks into InventoryMoveItemEvent and is therefore way less laggy.")) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onPlayerItemHeld(PlayerItemHeldEvent event) { // Fired when a hot bar item selection changes
                    if (legalityOf(event.getPlayer().getInventory().getItem(event.getNewSlot())) != ItemLegality.LEGAL
                            || legalityOf(event.getPlayer().getInventory().getItem(event.getPreviousSlot())) != ItemLegality.LEGAL) {
                        event.setCancelled(true);
                    }
                }
            });
        }

        final boolean checkOnChunkload = config.getBoolean(configPath + ".check-on-chunkload.enable", false,
                "WARNING: CHECKING ON CHUNKLOAD IS NOT RECOMMENDED AS IT IS VERY RESOURCE INTENSE.\n" +
                        "BE VERY SURE YOU ACTUALLY NEED THIS.\n" +
                        "Iterates over all blocks in a chunk when it is loaded and checks any inventories\n" +
                        "for illegals. If a container with illegals is found, the container will be REMOVED.");
        final boolean removeContainers = config.getBoolean(configPath + ".check-on-chunkload.remove-container", false,
                "If set to true, immediately replaces the container with air. Otherwise, will try\n" +
                        "to handle items separately.");
        if (checkOnChunkload) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
                private void onChunkLoad(ChunkLoadEvent event) {
                    if (event.isNewChunk()) return;
                    Chunk chunk = event.getChunk();
                    if (ChunkUtil.isRetrievalUnsafe(chunk)) return;

                    final int minY = WorldUtil.getMinWorldHeight(event.getWorld());
                    final int maxY = event.getWorld().getMaxHeight();

                    for (int x = 0; x < 16; x++) {
                        for (int z = 0; z < 16; z++) {
                            for (int y = minY; y < maxY; y++) {
                                Block block = chunk.getBlock(x, y, z);
                                if (!MaterialUtil.INVENTORY_HOLDERS.contains(block.getType())) continue;

                                if (removeContainers) {
                                    if (legalityOf(((InventoryHolder) block.getState(false)).getInventory()) != ItemLegality.LEGAL)
                                        block.setType(XMaterial.AIR.get(), false);
                                } else {
                                    BlockState blockState = block.getState(false);
                                    for (ItemStack itemStack : ((InventoryHolder) blockState).getInventory())
                                        handleItem(itemStack, legalityOf(itemStack));
                                    blockState.update(true, false);
                                }
                            }
                        }
                    }
                }
            });
        }

        this.listenerCooldowns = Caffeine.newBuilder().expireAfterWrite(Duration.ofMinutes(5)).build();
        final Duration delay = Duration.ofMillis(config.getInt(configPath+".check-rate-limit-millis", 3000,
                "The time in milliseconds to wait before performing another check,\n" +
                "if a check was positive. Helps with lag resulting from repeatedly\n" +
                "checking illegals."));
        this.createIfAbsent = eventClass -> new ExpiringSet<>(delay);
    }

    public abstract @NotNull ItemLegality legalityOf(@Nullable ItemStack itemStack);

    public abstract void handleItem(ItemStack itemStack, ItemLegality legality);

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        optionalListeners.forEach(optional -> plugin.getServer().getPluginManager().registerEvents(optional, plugin));
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        optionalListeners.forEach(HandlerList::unregisterAll);
        optionalListeners.clear();
        for (Map.Entry<Class<? extends Event>, ExpiringSet<Object>> entry : listenerCooldowns.asMap().entrySet()) {
            entry.getValue().clear();
            entry.getValue().cleanUp();
        }
        listenerCooldowns.invalidateAll();
        listenerCooldowns.cleanUp();
    }

    public ItemLegality legalityOf(Iterable<ItemStack> itemStacks) {
        if (itemStacks == null) {
            return ItemLegality.LEGAL;
        }

        for (ItemStack itemStack : itemStacks) {
            if (legalityOf(itemStack) != ItemLegality.LEGAL) {
                return ItemLegality.CONTAINS_ILLEGAL;
            }
        }

        return ItemLegality.LEGAL;
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerItemConsume(PlayerItemConsumeEvent event) {
        if (event.isCancelled() && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) return;

        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onBlockDispense(BlockDispenseEvent event) {
        if (event.isCancelled() && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getBlock().getLocation())) {
            event.setCancelled(true);
            return;
        }

        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getBlock().getLocation());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerArmorChange(PlayerArmorChangeEvent event) {
        if (illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return; // Cant cancel this event

        if (!AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) {
            handleItem(event.getNewItem(), legalityOf(event.getNewItem()));
            handleItem(event.getOldItem(), legalityOf(event.getOldItem()));
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onInventoryClick(InventoryClickEvent event) {
        if (guiPluginsSupported && event.getInventory().getLocation() == null) return;

        if (illegalHandling == IllegalHandling.PREVENT_USE_ONLY) {
            if (    event.isCancelled()
                    || event.getClick() == ClickType.DROP
                    || event.getClick() == ClickType.CONTROL_DROP
                    || event.getClick() == ClickType.WINDOW_BORDER_LEFT
                    || event.getClick() == ClickType.WINDOW_BORDER_RIGHT) {
                return;
            }
        }

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getWhoClicked().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getWhoClicked(), bypassPermission.node()).toBoolean()) return;

        ItemStack currentItem = event.getCurrentItem();
        ItemLegality clickedLegality = legalityOf(currentItem);
        if (clickedLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(currentItem, clickedLegality);
            event.setCurrentItem(currentItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
        }

        ItemLegality cursorLegality = legalityOf(event.getCursor());
        if (cursorLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCursor(), cursorLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onInventoryDrag(InventoryDragEvent event) {
        if (illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;
        if (guiPluginsSupported && event.getInventory().getLocation() == null) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getWhoClicked().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getWhoClicked(), bypassPermission.node()).toBoolean()) return;

        for (ItemStack invItem : event.getInventory()) {
            ItemLegality invItemLegality = legalityOf(invItem);
            if (invItemLegality != ItemLegality.LEGAL) {
                event.setCancelled(true);
                handleItem(invItem, invItemLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (event.isCancelled() && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (event.getDamager().getType() == EntityType.PLAYER) {
            final Player player = (Player) event.getDamager();

            if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(player.getUniqueId())) {
                event.setCancelled(true);
                return;
            }

            if (AnarchyExploitFixes.permissions().permissionValue(player, bypassPermission.node()).toBoolean()) return;

            ItemStack mainHandItem = player.getInventory().getItemInMainHand();
            final ItemLegality mainHandLegality = legalityOf(mainHandItem);
            if (mainHandLegality != ItemLegality.LEGAL) {
                event.setCancelled(true);
                handleItem(mainHandItem, mainHandLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(player.getUniqueId());
            }

            ItemStack offHandItem = player.getInventory().getItemInOffHand();
            final ItemLegality offHandLegality = legalityOf(offHandItem);
            if (offHandLegality != ItemLegality.LEGAL) {
                event.setCancelled(true);
                handleItem(offHandItem, offHandLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(player.getUniqueId());
            }
            return;
        }

        if (EntityUtil.isLivingEntity(event.getDamager())) {
            if (legalityOf(((LivingEntity) event.getDamager()).getActiveItem()) != ItemLegality.LEGAL) {
                event.setCancelled(true);
                if (illegalHandling != IllegalHandling.PREVENT_USE_ONLY)
                    event.getDamager().remove();
                return;
            }
        }

        if (EntityUtil.isInventoryHolder(event.getDamager())) {
            if (legalityOf(((InventoryHolder) event.getDamager()).getInventory()) != ItemLegality.LEGAL) {
                event.setCancelled(true);
                if (illegalHandling != IllegalHandling.PREVENT_USE_ONLY)
                    event.getDamager().remove();
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        if (event.isCancelled() && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) return;

        ItemStack pickUpItem = event.getItem().getItemStack();
        final ItemLegality legality = legalityOf(pickUpItem);
        if (legality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(pickUpItem, legality);
            event.getItem().setItemStack(pickUpItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerDropItem(PlayerDropItemEvent event) {
        if (event.isCancelled() && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) return;

        ItemStack droppedItem = event.getItemDrop().getItemStack();
        final ItemLegality legality = legalityOf(droppedItem);
        if (legality != ItemLegality.LEGAL) {
            handleItem(droppedItem, legality);
            event.getItemDrop().setItemStack(droppedItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerInteract(PlayerInteractEvent event) {
        if (event.useItemInHand() == Event.Result.DENY && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) return;

        ItemStack interactItem = event.getItem();
        final ItemLegality legality = legalityOf(interactItem);
        if (legality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(interactItem, legality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerInteractEntity(PlayerInteractEntityEvent event) {
        if (event.isCancelled() && illegalHandling == IllegalHandling.PREVENT_USE_ONLY) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (AnarchyExploitFixes.permissions().permissionValue(event.getPlayer(), bypassPermission.node()).toBoolean()) return;

        ItemStack handItem = event.getPlayer().getInventory().getItem(event.getHand());
        final ItemLegality legality = legalityOf(handItem);
        if (legality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(handItem, legality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }
}
