package me.xginko.aef.modules.preventions;

import com.cryptomorin.xseries.XMaterial;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.modules.AEFModule;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;

import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

public class MapSpam extends AEFModule implements Listener {

    private final Cache<UUID, MapCreations> trackedPlayers;
    private final long cooldownMillis;
    private final int mapCreateLimit;
    private final boolean shouldNotifyPlayers;

    public MapSpam() {
        super("preventions.prevent-map-reset-spam");
        config.addComment(configPath + ".enable",
                "Puts a cooldown on creating maps so players cant reset\n" +
                        "map arts that easily.\n" +
                        "Only needed on versions below 1.12 and lower.\n" +
                        "Bypass permission: " + AEFPermission.BYPASS_MAP_SPAM.string());
        this.shouldNotifyPlayers = config.getBoolean(configPath + ".notify-players", true,
                "Sends a message to players telling them how many maps\n" +
                        "they can create per time");
        this.cooldownMillis = TimeUnit.MINUTES.toMillis(Math.max(1,
                config.getInt(configPath + ".cooldown-time-in-minutes", 60)));
        this.trackedPlayers = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(cooldownMillis)).build();
        this.mapCreateLimit = config.getInt(configPath + ".max-amount-of-maps-per-time", 4);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    private void onPlayerInteract(PlayerInteractEvent event) {
        if (event.getAction() == Action.LEFT_CLICK_AIR || event.getAction() == Action.LEFT_CLICK_BLOCK) return;
        final ItemStack mapItem = event.getItem();
        if (mapItem == null || mapItem.getType() != XMaterial.MAP.parseMaterial()) return;
        final Player player = event.getPlayer();
        if (player.hasPermission(AEFPermission.BYPASS_MAP_SPAM.string())) return;

        MapCreations mapCreations = trackedPlayers.get(player.getUniqueId(), k -> new MapCreations());
        long currentTime = System.currentTimeMillis();

        long millisBetweenPrevMapCreateAndNow = currentTime - mapCreations.lastCreateTime.getAndSet(currentTime);
        int mapsCreated = mapCreations.count.getAndIncrement();

        if (mapsCreated >= mapCreateLimit) {
            event.setCancelled(true);
            player.updateInventory();
            if (shouldNotifyPlayers) player.sendMessage(AnarchyExploitFixes.getLang(player.getLocale()).mapspam_exceededLimit
                    .replace("%time%", toHumanTime(cooldownMillis - millisBetweenPrevMapCreateAndNow)));
            return;
        }

        if (shouldNotifyPlayers) {
            int remaining = mapCreateLimit - mapsCreated;
            if (remaining > 0) player.sendMessage(AnarchyExploitFixes.getLang(player.getLocale()).mapspam_youCanOnlyCreateXMoreMaps
                    .replace("%amount%", Integer.toString(remaining))
                    .replace("%time%", toHumanTime(cooldownMillis - millisBetweenPrevMapCreateAndNow)));
        }
    }

    private static String toHumanTime(long milliseconds) {
        Duration duration = Duration.ofMillis(milliseconds);
        if (duration.isNegative()) duration = duration.negated();

        final int seconds = (int) (duration.getSeconds() % 60);
        final int minutes = (int) (duration.toMinutes() % 60);
        final int hours = (int) (duration.toHours() % 24);

        if (hours > 0) {
            return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%02dm %02ds", minutes, seconds);
        } else {
            return String.format("%02ds", seconds);
        }
    }

    private static class MapCreations {
        public AtomicLong lastCreateTime;
        public AtomicInteger count;
        public MapCreations() {
            this.lastCreateTime = new AtomicLong(System.currentTimeMillis());
            this.count = new AtomicInteger(1);
        }
    }
}
