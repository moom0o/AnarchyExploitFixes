package me.xginko.aef.modules.preventions;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.modules.AEFModule;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.util.NumberConversions;

import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

public class BedTrap extends AEFModule implements Listener {

    private final long timeInSeconds;
    private final double maxBedDistanceSquared;
    private final int maxDeathsPerTime;
    private final boolean logIsEnabled;

    private Cache<UUID, AtomicInteger> playerDeathNearBedCount;

    public BedTrap() {
        super("preventions.anti-bed-trap", false,
                "Resets a players bed respawn they die too many times within\n" +
                "a certain timeframe.");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.maxDeathsPerTime = config.getInt(configPath + ".max-deaths-per-time", 7,
                "Amount of times player can die until he is determined as bed-trapped.");
        this.timeInSeconds = Math.max(1, config.getInt(configPath + ".time-in-seconds", 5,
                "Time until death counter will be reset again"));
        this.maxBedDistanceSquared = NumberConversions.square(config.getDouble(configPath + ".max-distance-from-bed", 6.0));
    }

    @Override
    public void enable() {
        playerDeathNearBedCount = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(timeInSeconds)).build();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (playerDeathNearBedCount != null) {
            playerDeathNearBedCount.invalidateAll();
            playerDeathNearBedCount.cleanUp();
            playerDeathNearBedCount = null;
        }
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onDeath(PlayerDeathEvent event) {
        if (!isNearBedSpawn(event.getEntity())) return;

        if (playerDeathNearBedCount.get(event.getEntity().getUniqueId(), k -> new AtomicInteger()).incrementAndGet() > maxDeathsPerTime) {
            event.getEntity().setBedSpawnLocation(null, true);
            if (logIsEnabled) info("Reset bed respawn of potentially bed-trapped player '" + event.getEntity().getName() + "'");
        }
    }

    private boolean isNearBedSpawn(Player player) {
        final Location bedSpawn = player.getBedSpawnLocation();
        if (bedSpawn == null) return false;
        if (!player.getWorld().getUID().equals(bedSpawn.getWorld().getUID())) return false;
        return player.getLocation().distanceSquared(bedSpawn) > maxBedDistanceSquared;
    }
}