package me.xginko.aef.modules.lagpreventions.redstoneProtector;

import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import org.bukkit.event.EventHandler;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockRedstoneEvent;

import java.util.HashMap;
import java.util.Map;


public class RedstoneProtector extends AEFModule implements Listener, Runnable {
    private final int regionSize, LimitResetTime, redstoneLimit, slimeLimit, LimitBanTime;
    private final boolean logIsEnabled;
    private final Map<Integer, RegionData> regionMap;

    public RedstoneProtector() {
        super("lag-preventions.redstone-protector");
        this.regionMap = new HashMap<>();
        config.addComment(configPath + ".enable", "A modern defense against lag machines that are made as mechanisms.\nThe configuration has basic settings, but you can do better.\nThe defense has been used on the 6g6s.org project for several years and has performed well.\nSlime limiter is used to fix EMP lag of the machine: https://www.youtube.com/watch?v=R_S8o4hngNI\nDemonstration of how this module works: https://www.youtube.com/watch?v=Rmlm-OVuBss");
        this.regionSize = config.getInt(configPath + ".region-size", 1500, "Radius of the region in blocks. Redstone is limited by region. It is recommended to be at least 1000.");
        this.LimitResetTime = config.getInt(configPath + ".limit.reset-time", 5000, "The time after which the redstone burst counter will reset. (in milliseconds)");
        this.LimitBanTime = config.getInt(configPath + ".limit-ban-time", 180, "The time for which all redstone will be disabled if the limit is exceeded. (in seconds)");
        this.redstoneLimit = config.getInt(configPath + ".redstone-limit.count", 5000, "Maximum number of redstone bursts in x milliseconds.");
        this.slimeLimit = config.getInt(configPath + ".slime-limit.count", 500, "Maximum number of movements for slime blocks in x milliseconds.");
        this.logIsEnabled = config.getBoolean(configPath + ".log", true);
        plugin.getServer().getScheduler().scheduleSyncRepeatingTask(plugin, this, 10 * 20, 20 * (LimitResetTime/1000));
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @EventHandler
    private void redstoneFlashEvent(BlockRedstoneEvent event) {
        int regionNumber = RegionData.getRegion(event.getBlock().getX(), event.getBlock().getZ(), this.regionSize);

        if (!regionMap.containsKey(regionNumber)) {
            RegionData regionData = new RegionData(0, 0, false);
            regionMap.put(regionNumber, regionData);
        }

        RegionData region = regionMap.get(regionNumber);
        region.setCurrentRedstoneLimit(region.getCurrentRedstoneLimit() + 1);

        if (region.getCurrentRedstoneLimit() > redstoneLimit) {
            if (!region.isBlocked()) {
                blockRegion(regionNumber, LimitBanTime);
                if (logIsEnabled) warn("Blocked redstone in the region " + regionNumber + " at " +
                        LocationUtil.toString(event.getBlock().getLocation()) +
                        " because the limit has been exceeded. Limit: " + region.getCurrentRedstoneLimit() + " / " + redstoneLimit);
            }
        }

        if (region.isBlocked()) {
            event.setNewCurrent(0);
        }
    }

    @EventHandler
    private void SlimePatch(BlockPistonExtendEvent event) {
        int regionNumber = RegionData.getRegion(event.getBlock().getX(), event.getBlock().getZ(), this.regionSize);

        if (!regionMap.containsKey(regionNumber)) {
            RegionData regionData = new RegionData(0, 0, false);
            regionMap.put(regionNumber, regionData);
        }

        RegionData region = regionMap.get(regionNumber);
        region.setCurrentSlimeLimit(region.getCurrentSlimeLimit() + 1);

        if (region.getCurrentSlimeLimit() > slimeLimit) {
            if (!region.isBlocked()) {
                blockRegion(regionNumber, LimitBanTime);
                if (logIsEnabled) warn("Blocked redstone in the region " + regionNumber + " at " +
                        LocationUtil.toString(event.getBlock().getLocation()) +
                        " because the slime limit has been exceeded. Limit: " + region.getCurrentSlimeLimit() + " / " + slimeLimit);
            }
        }

        if (region.isBlocked()) {
            event.setCancelled(true);
        }
    }
    public void blockRegion(int regionNumber, long durationInSeconds) {
        if (regionMap.containsKey(regionNumber)) {
            RegionData regionData = regionMap.get(regionNumber);
            long currentTime = System.currentTimeMillis() / 1000;
            regionData.setBlocked(true, currentTime, durationInSeconds);
        }
    }

    @Override
    public void run() {
        for (RegionData regionData : regionMap.values()) {
            regionData.setCurrentRedstoneLimit(0);
            regionData.setCurrentSlimeLimit(0);
        }
    }
}
