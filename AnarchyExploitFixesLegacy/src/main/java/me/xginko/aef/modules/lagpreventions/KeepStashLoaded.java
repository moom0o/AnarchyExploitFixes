package me.xginko.aef.modules.lagpreventions;

import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.xginko.aef.utils.ChunkUtil;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.WorldUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ChunkUID;
import me.xginko.aef.utils.models.Disableable;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.world.ChunkLoadEvent;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class KeepStashLoaded extends AEFModule implements Disableable, Runnable, Listener {

    private final Map<ChunkUID, Long> forceLoadedChunks;
    private final Set<Material> storageTypes;
    private final long keepLoadedMillis;
    private final int stashCount;
    private final boolean logIsEnabled;
    private final Map<String, Integer> worldsAndTheirRadiuses = new HashMap<>();

    public KeepStashLoaded() {
        super("lag-preventions.keep-stash-chunks-loaded");
        this.forceLoadedChunks = new ConcurrentHashMap<>();
        config.addComment(configPath + ".enable",
                "Idea by 6g6s admin kumori:\n"+
                "Improves lag generated by large stash chunks constantly loading and\n"+
                "unloading by setting them force loaded. This might cause increased ram\n"+
                "usage, so keep an eye out for that.\n" +
                "Only works on 1.15+. Will not enable on unsupported versions.");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.stashCount = config.getInt(configPath + ".container-block-threshold", 50,
                "How many container blocks have to be in a chunk for it to be seen\n"+
                "as a stash chunk to keep force loaded.");
        this.keepLoadedMillis = TimeUnit.MINUTES.toMillis(config.getInt(configPath + ".keep-loaded-minutes", 60,
                "The time in minutes a stash chunks will be kept force loaded before\n"+
                "setting it back to normal."));
        this.storageTypes = config.getList(configPath + ".container-types", MaterialUtil.INVENTORY_HOLDER_BLOCKS
                        .stream()
                        .map(Enum::name)
                        .collect(Collectors.toList()))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

        Map<String, Object> defaults = new HashMap<>();
        defaults.put("world", 5000);
        defaults.put("world_nether", 5000);
        defaults.put("world_the_end", 5000);
        ConfigSection section = config.getConfigSection(configPath + ".worlds", defaults, "Spawn radius in which stashes should not be checked");
        for (String world : section.getKeys(false)) {
            try {
                Integer radius = Integer.valueOf(section.getString(world));
                this.worldsAndTheirRadiuses.put(world, radius);
            } catch (NumberFormatException e) {
                warn("Radius for world '" + world + "' is not a valid integer.");
            }
        }
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        plugin.getServer().getScheduler().runTaskTimerAsynchronously(plugin, this, 1L, 20L);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            Chunk chunk = entry.getKey().getChunk();
            if (chunk != null)
                ChunkUtil.setForceLoaded(chunk, false);
            forceLoadedChunks.remove(entry.getKey());
        }
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false) && ChunkUtil.canSetChunksForceLoaded();
    }

    @Override
    public void run() {
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            if (System.currentTimeMillis() < entry.getValue()) {
                continue;
            }

            Chunk chunk = entry.getKey().getChunk();
            if (chunk == null) {
                forceLoadedChunks.remove(entry.getKey());
                if (logIsEnabled)
                    info("Removing key that returns a null chunk: "+entry.getKey()+".");
                continue;
            }

            ChunkUtil.setForceLoaded(chunk, false);
            forceLoadedChunks.remove(entry.getKey());
            if (logIsEnabled)
                info("Set chunk "+entry.getKey()+" to no longer force loaded.");
        }
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    private void onChunkLoad(ChunkLoadEvent event) {
        if (event.isNewChunk()) return;
        Chunk chunk = event.getChunk();

        final String world = chunk.getWorld().getName();
        if (!worldsAndTheirRadiuses.containsKey(world)) return;

        final Integer disabledRadius = worldsAndTheirRadiuses.get(world);
        final Location chunkLocation = chunk.getWorld().getLocationAtKey(chunk.getChunkKey());
        if (LocationUtil.getDistance2DTo00(chunkLocation) < disabledRadius) return;

        final int minY = WorldUtil.getMinWorldHeight(event.getWorld());
        final int maxY = event.getWorld().getMaxHeight();

        boolean setForceLoaded = false;

        int count = 0;
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                for (int y = minY; y < maxY; y++) {
                    if (storageTypes.contains(chunk.getBlock(x, y, z).getType())) {
                        count++;
                        if (count > stashCount) {
                            setForceLoaded = true;
                            break;
                        }
                    }
                }
            }
        }

        if (!setForceLoaded) {
            return;
        }

        forceLoadedChunks.computeIfAbsent(ChunkUID.of(chunk), chunkUID -> {
            ChunkUtil.setForceLoaded(chunk, true);
            if (logIsEnabled)
                info("Set chunk "+chunkUID+" to force loaded.");
            return System.currentTimeMillis() + keepLoadedMillis;
        });
    }
}
