package me.xginko.aef.modules.dupepreventions;

import com.cryptomorin.xseries.XMaterial;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.MaterialUtil;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPistonEvent;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockPistonRetractEvent;

import java.util.Collections;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class BlockEntityDupe extends AEFModule implements Listener {

    private final Map<Material, Boolean> materials = new EnumMap<>(Material.class);

    private Set<Block> removalList;

    public BlockEntityDupe() {
        super("dupe-preventions.block-entity-dupe", false,
                "Will prevent Pistons that are pusing carpets/rails/tnt from working.\n" +
                        "This isn't recommended to be used for turning everything off.\n" +
                        "Use papers settings for that.\n" +
                        "This is intended for admins that want to allow specific dupes only.");

        if (config.getBoolean(configPath + ".carpets.prevent", true)) {
            boolean remove = config.getBoolean(configPath + ".carpets.delete", true);
            for (Material material : MaterialUtil.CARPETS) {
                materials.put(material, remove);
            }
        }

        if (config.getBoolean(configPath + ".rails.prevent", true)) {
            boolean remove = config.getBoolean(configPath + ".rails.delete", true);
            for (Material material : MaterialUtil.RAILS) {
                materials.put(material, remove);
            }
        }

        if (config.getBoolean(configPath + ".tnt.prevent", false)) {
            materials.put(XMaterial.TNT.get(), config.getBoolean(configPath + ".tnt.delete", true));
        }
    }

    @Override
    public void enable() {
        removalList = Collections.newSetFromMap(new ConcurrentHashMap<>());
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (removalList != null) {
            setBlocksToAir();
            removalList = null;
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPistonExtend(BlockPistonExtendEvent event) {
        onPistonEvent(event, event.getBlocks());
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPistonRetract(BlockPistonRetractEvent event) {
        onPistonEvent(event, event.getBlocks());
    }

    private void onPistonEvent(BlockPistonEvent event, List<Block> affectedBlocks) {
        if (affectedBlocks.isEmpty()) return;

        for (Block block : affectedBlocks) {
            if (materials.containsKey(block.getType())) {
                event.setCancelled(true);
                if (materials.get(block.getType())) {
                    removalList.add(block);
                }
            }
        }

        setBlocksToAir();
    }

    private void setBlocksToAir() {
        if (removalList.isEmpty()) return;

        plugin.getServer().getScheduler().runTaskLater(plugin, () -> {
            for (Block block : removalList) {
                block.setType(XMaterial.AIR.get(), false);
                removalList.remove(block);
            }
        }, 1L);
    }
}
