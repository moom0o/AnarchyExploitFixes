package me.xginko.aef.modules.combat.auras;

import me.xginko.aef.modules.AEFModule;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerKickEvent;
import org.bukkit.event.player.PlayerQuitEvent;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

public abstract class AuraDelayModule extends AEFModule implements Listener {

    protected final long placeDelayNanos, breakDelayNanos;
    protected final boolean updateInventory;

    protected Map<UUID, Long> placeCooldowns, breakCooldowns;

    public AuraDelayModule(String configPath, long defPlaceDelayMillis, long defBreakDelayMillis) {
        this(configPath, false, defPlaceDelayMillis, defBreakDelayMillis);
    }

    public AuraDelayModule(String configPath, boolean defEnabled, long defPlaceDelayMillis, long defBreakDelayMillis) {
        super(configPath, defEnabled);
        this.updateInventory = config.getBoolean(configPath + ".update-inventory-on-cancel", false,
                "Can help with desync but recommended to leave off unless you have issues.");
        placeDelayNanos = TimeUnit.MILLISECONDS.toNanos(
                config.getLong(configPath + ".place-delay-millis", defPlaceDelayMillis, "1 tick = 50 ms"));
        breakDelayNanos = TimeUnit.MILLISECONDS.toNanos(
                config.getLong(configPath + ".break-delay-millis", defBreakDelayMillis));
    }

    @Override
    public void enable() {
        breakCooldowns = new ConcurrentHashMap<>();
        placeCooldowns = new ConcurrentHashMap<>();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (breakCooldowns != null) {
            breakCooldowns.clear();
            breakCooldowns = null;
        }
        if (placeCooldowns != null) {
            placeCooldowns.clear();
            placeCooldowns = null;
        }
    }

    protected boolean isOnCooldown(UUID uuid, Map<UUID, Long> cooldownMap, long delayNanos) {
        if (delayNanos <= 0) {
            return false;
        }

        if (cooldownMap.containsKey(uuid) && cooldownMap.get(uuid) > System.nanoTime()) {
            return true;
        }

        cooldownMap.put(uuid, System.nanoTime() + delayNanos);
        return false;
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onPlayerQuit(PlayerQuitEvent event) {
        placeCooldowns.remove(event.getPlayer().getUniqueId());
        breakCooldowns.remove(event.getPlayer().getUniqueId());
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onPlayerKick(PlayerKickEvent event) {
        placeCooldowns.remove(event.getPlayer().getUniqueId());
        breakCooldowns.remove(event.getPlayer().getUniqueId());
    }
}
