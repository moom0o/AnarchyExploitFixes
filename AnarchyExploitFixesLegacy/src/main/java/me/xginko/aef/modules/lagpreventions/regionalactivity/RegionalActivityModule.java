package me.xginko.aef.modules.lagpreventions.regionalactivity;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.models.BlockRegion2D;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.EntityType;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.EnumMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 *  Credits to the initial idea of measuring burst activity within a certain region
 *  of the world go to kumori (Soft1k) of 3b3t.org.
 */
public abstract class RegionalActivityModule extends AEFModule implements Listener {

    protected final long cacheTimeMillis, pauseTimeMillis;
    protected final double checkRadius, pauseTPS, pauseMSPT;
    protected final int totalActivityLimit;
    protected final boolean logIsEnabled;

    protected Cache<BlockRegion2D, RegionData> regionDataCache;

    public RegionalActivityModule(
            String subConfigPath, boolean defEnabled, boolean deflogEnabled, int totalLimit, double defCheckRadius,
            int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT
    ) {
        this(subConfigPath, defEnabled, deflogEnabled, totalLimit, defCheckRadius,
                defPauseMillis, defCacheMillis, defPauseTPS, defPauseMSPT, null);
    }

    public RegionalActivityModule(
            String subConfigPath, boolean defEnabled, boolean deflogEnabled, int defTotalLimit, double defCheckRadius,
            int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT, String comment) {
        super("lag-preventions.regional-activity."+subConfigPath, defEnabled, comment);
        String configPath = "lag-preventions.regional-activity." + subConfigPath;
        this.logIsEnabled = config.getBoolean(configPath + ".log", deflogEnabled);
        this.totalActivityLimit = config.getInt(configPath + ".total-limit", defTotalLimit);
        this.checkRadius = config.getDouble(configPath + ".check-radius-blocks", defCheckRadius,
                "The radius in blocks in which activity will be grouped together and measured.");
        this.pauseTimeMillis = config.getInt(configPath + ".pause-time-millis", defPauseMillis,
                "The time in milliseconds all related activity will be blocked if it exceeded\n" +
                        "the configured limit.");
        this.cacheTimeMillis = Math.max(100L, config.getInt(configPath + ".data-keep-time-millis", defCacheMillis,
                "The time in milliseconds before a region and its data will be expired\n" +
                        "if no activity has been detected.\n" +
                        "For proper functionality, needs to be at least as long as your pause time."));
        this.pauseTPS = config.getDouble(configPath + ".pause-TPS", defPauseTPS,
                "The TPS at which to cancel the physics entirely.");
        this.pauseMSPT = config.getDouble(configPath + ".pause-MSPT", defPauseMSPT,
                "The MSPT at which to cancel the physics entirely.");
    }

    @Override
    public void enable() {
        regionDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(cacheTimeMillis)).build();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (regionDataCache != null) {
            regionDataCache.invalidateAll();
            regionDataCache.cleanUp();
            regionDataCache = null;
        }
    }

    protected @NotNull BlockRegion2D getRegion(Location location) {
        // Find and return region containing this location
        for (Map.Entry<BlockRegion2D, RegionData> regionDataEntry : regionDataCache.asMap().entrySet()) {
            if (regionDataEntry.getKey().contains(location)) {
                return regionDataEntry.getKey();
            }
        }
        // Create and cache region if none exists
        BlockRegion2D region = BlockRegion2D.of(location.getWorld(), location.getX(), location.getZ(), checkRadius);
        regionDataCache.put(region, new RegionData(region));
        return region;
    }

    protected @NotNull RegionalActivityModule.RegionData getRegionData(Location location) {
        return regionDataCache.get(getRegion(location), RegionData::new);
    }

    protected <T extends Event> boolean shouldCancelEvent(T event, Location location) {
        return shouldCancelBecauseLagging(event) || shouldCancelBecauseTotalActivity(event, location);
    }

    protected <T extends Event> boolean shouldCancelBecauseLagging(T event) {
        double ticksPerSecond = AnarchyExploitFixes.tickReporter().getTPS();
        double milliSecondsPerTick = AnarchyExploitFixes.tickReporter().getMSPT();
        if (ticksPerSecond <= pauseTPS || milliSecondsPerTick >= pauseMSPT) {
            if (logIsEnabled) info("Cancelling " + event.getClass().getSimpleName() + " because server is lagging." +
                    " (tps="+String.format("%.4f", ticksPerSecond)+" | mspt="+String.format("%.4f", milliSecondsPerTick)+")");
            return true;
        }
        return false;
    }

    protected <T extends Event> boolean shouldCancelBecauseTotalActivity(T event, Location location) {
        RegionData regionData = getRegionData(location);

        if (regionData.getTotalActivityData().resumeTimeMillis.get() > System.currentTimeMillis()) {
            if (logIsEnabled) info("Cancelling " + event.getClass().getSimpleName() + " indiscriminately at " +
                    LocationUtil.toString(location) + " because the region exceeded the total activity limit.");
            return true;
        }

        if (regionData.getTotalActivityData().activityCount.incrementAndGet() > totalActivityLimit) {
            if (logIsEnabled) {
                info(   "Disabling in a radius of " + checkRadius + " blocks from center at " +
                        "x=" + regionData.region.getCenterX() + ", z=" + regionData.region.getCenterZ() +
                        " in world " + location.getWorld().getName() + " for " + pauseTimeMillis + "ms, " +
                        "because of too high activity within the configured timeframe: " +
                        regionData.getTotalActivityData().activityCount + " (limit: " + totalActivityLimit + ")");
            }
            regionData.getTotalActivityData().resumeTimeMillis.set(System.currentTimeMillis() + pauseTimeMillis);
            regionData.getTotalActivityData().activityCount.set(0); // Reset count when region is cooling down
            return true;
        }

        return false;
    }

    protected static class RegionData {

        public final BlockRegion2D region;
        private final ActivityData totalActivityData;
        private final Map<Material, ActivityData> blockActivityData;
        private final Map<EntityType, ActivityData> entityActivityData;

        public RegionData(BlockRegion2D region) {
            this.region = region;
            this.totalActivityData = new ActivityData();
            this.blockActivityData = new EnumMap<>(Material.class);
            this.entityActivityData = new EnumMap<>(EntityType.class);
        }

        public ActivityData getTotalActivityData() {
            return totalActivityData;
        }

        public ActivityData getBlockActivityData(Material material) {
            return blockActivityData.computeIfAbsent(material, k -> new ActivityData());
        }

        public ActivityData getEntityActivityData(EntityType entityType) {
            return entityActivityData.computeIfAbsent(entityType, k -> new ActivityData());
        }

        public static class ActivityData {
            public final AtomicInteger activityCount = new AtomicInteger();
            public final AtomicLong resumeTimeMillis = new AtomicLong();
        }
    }
}
