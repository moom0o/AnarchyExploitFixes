package me.xginko.aef.modules.lagpreventions.regionalactivity;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.models.BlockRegion2D;
import org.bukkit.Location;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 *  Credits to the initial idea of measuring burst activity within a certain region
 *  of the world go to kumori (Soft1k) of 3b3t.org.
 */
public abstract class RegionalActivityModule extends AEFModule implements Listener {

    protected final long cacheTimeMillis, pauseTimeMillis;
    protected final double checkRadius, pauseTPS, pauseMSPT;
    protected final boolean logIsEnabled;

    protected Cache<BlockRegion2D, RegionData> regionDataCache;

    public RegionalActivityModule(
            String subConfigPath, boolean defEnabled, boolean deflogEnabled, double defCheckRadius,
            int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT
    ) {
        this(subConfigPath, defEnabled, deflogEnabled, defCheckRadius,
                defPauseMillis, defCacheMillis, defPauseTPS, defPauseMSPT, null);
    }

    public RegionalActivityModule(
            String subConfigPath, boolean defEnabled, boolean deflogEnabled, double defCheckRadius,
            int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT, String comment
    ) {
        super("lag-preventions.regional-activity."+subConfigPath, defEnabled, comment);
        String configPath = "lag-preventions.regional-activity."+subConfigPath;
        this.logIsEnabled = config.getBoolean(configPath + ".log", deflogEnabled);
        this.checkRadius = config.getDouble(configPath + ".check-radius-blocks", defCheckRadius,
                "The radius in blocks in which activity will be grouped together and measured.");
        this.pauseTimeMillis = config.getInt(configPath + ".pause-time-millis", defPauseMillis,
                "The time in milliseconds all related activity will be blocked if it exceeded\n" +
                        "the configured limit.");
        this.cacheTimeMillis = Math.max(100L, config.getInt(configPath + ".data-keep-time-millis", defCacheMillis,
                "The time in milliseconds before a region and its data will be expired\n" +
                "if no activity has been detected.\n" +
                "For proper functionality, needs to be at least as long as your pause time."));
        this.regionDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                config.getInt(configPath + ".data-keep-time-millis", defCacheMillis,
                        "The time in milliseconds before a region and its data will be expired\n" +
                                "if no activity has been detected.\n" +
                                "For proper functionality, needs to be at least as long as your pause time."))).build();
        this.pauseTPS = config.getDouble(configPath + ".pause-TPS", defPauseTPS,
                "The TPS at which to cancel the physics entirely.");
        this.pauseMSPT = config.getDouble(configPath + ".pause-MSPT", defPauseMSPT,
                "The MSPT at which to cancel the physics entirely.");
    }

    @Override
    public void enable() {
        regionDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(cacheTimeMillis)).build();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (regionDataCache != null) {
            regionDataCache.invalidateAll();
            regionDataCache.cleanUp();
            regionDataCache = null;
        }
    }

    @SuppressWarnings("DataFlowIssue")
    protected @NotNull RegionalActivityModule.RegionData getRegionData(Location location) {
        return regionDataCache.get(getRegion(location), RegionData::new);
    }

    public boolean shouldCancelActivity(Event event, Location location, int limit) {
        double tps = AnarchyExploitFixes.tickReporter().getTPS();
        double mspt = AnarchyExploitFixes.tickReporter().getMSPT();

        if (tps <= pauseTPS || mspt >= pauseMSPT) {
            if (logIsEnabled) info("Cancelling " + event.getClass().getSimpleName() + " because server is lagging." +
                    " (tps="+String.format("%.4f", tps)+" | mspt="+String.format("%.4f", mspt)+")");
            return true;
        }

        RegionData regionData = getRegionData(location);

        if (regionData.resumeTime.get() > System.currentTimeMillis()) {
            return true;
        }

        if (regionData.activityCount.incrementAndGet() > limit) {
            if (logIsEnabled) {
                info(   "Disabling in a radius of " + checkRadius + " blocks from center at " +
                        "x=" + regionData.region.getCenterX() + ", z=" + regionData.region.getCenterZ() +
                        " in world " + location.getWorld().getName() + " for " + pauseTimeMillis + "ms, " +
                        "because of too high activity within the configured timeframe: " +
                        regionData.activityCount + " (limit: " + limit + ")");
            }
            regionData.resumeTime.set(System.currentTimeMillis() + pauseTimeMillis);
            regionData.activityCount.set(0); // Reset count when region is cooling down
            return true;
        }

        return false;
    }

    public @NotNull BlockRegion2D getRegion(Location location) {
        // Find and return region containing this location
        for (Map.Entry<BlockRegion2D, RegionData> regionDataEntry : regionDataCache.asMap().entrySet()) {
            if (regionDataEntry.getKey().contains(location)) {
                return regionDataEntry.getKey();
            }
        }
        // Create and cache region if none exists
        BlockRegion2D region = BlockRegion2D.of(location.getWorld(), location.getX(), location.getZ(), checkRadius);
        regionDataCache.put(region, new RegionData(region));
        return region;
    }

    protected static class RegionData {

        public final BlockRegion2D region;
        public final AtomicLong resumeTime;
        public final AtomicInteger activityCount;

        public RegionData(BlockRegion2D region) {
            this.region = region;
            this.activityCount = new AtomicInteger(0);
            this.resumeTime = new AtomicLong(0L);
        }
    }
}
